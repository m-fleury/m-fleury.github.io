<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IsaSAT_VMTF (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IsaSAT_VMTF</h1>

<span class="command">theory</span> <span class="name">IsaSAT_VMTF</span><br/>
<span class="keyword">imports</span> <a href="../../Unsorted/Watched_Literals/WB_Sort.html"><span class="name">WB_Sort</span></a> <a href="IsaSAT_Setup.html"><span class="name">IsaSAT_Setup</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IsaSAT_VMTF</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Watched_Literals.WB_Sort</span><span> </span><span>IsaSAT_Setup</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decision heuristic&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Code generation for the VMTF decision heuristic and the trail&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_next_search</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_next_search L = (&#955;((ns, m, fst_As, lst_As, next_search), to_remove).
    ((ns, m, fst_As, lst_As, L), to_remove))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_enqueue_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_enqueue_pre =
     (&#955;((M, L),(ns,m,fst_As,lst_As, next_search)). L &lt; length ns &#8743;
       (fst_As &#8800; None &#10230; the fst_As &lt; length ns) &#8743;
       (fst_As &#8800; None &#10230; lst_As &#8800; None) &#8743;
       m+1 &#8804; uint64_max)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_enqueue</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat &#8658; vmtf_option_fst_As &#8658; vmtf nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_enqueue = (&#955;M L (ns, m, fst_As, lst_As, next_search). do {
  ASSERT(defined_atm_pol_pre M L);
  de &#8592; RETURN (defined_atm_pol M L);
  case fst_As of
    None &#8658;RETURN ((ns[L := VMTF_Node m fst_As None], m+1, L, L,
            (if de then None else Some L)))
  | Some fst_As &#8658; do {
      let fst_As&#39; = VMTF_Node (stamp (ns!fst_As)) (Some L) (get_next (ns!fst_As));
      RETURN (ns[L := VMTF_Node (m+1) None (Some fst_As), fst_As := fst_As&#39;],
          m+1, L, the lst_As, (if de then next_search else Some L))
   }})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_enqueue_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN ooo vmtf_enqueue = (&#955;M L (ns, m, fst_As, lst_As, next_search). do {
    let de = defined_lit M (Pos L);
    case fst_As of
      None &#8658; RETURN (ns[L := VMTF_Node m fst_As None], m+1, L, L,
	   (if de then None else Some L))
    | Some fst_As &#8658;
       let fst_As&#39; = VMTF_Node (stamp (ns!fst_As)) (Some L) (get_next (ns!fst_As)) in
       RETURN (ns[L := VMTF_Node (m+1) None (Some fst_As), fst_As := fst_As&#39;],
	    m+1, L, the lst_As, (if de then next_search else Some L))})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_enqueue_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_enqueue</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 isa_vmtf_enqueue, uncurry2 (RETURN ooo vmtf_enqueue)) &#8712;
     [&#955;((M, L), _). L &#8712;# &#119964;]<span class="hidden">&#8681;</span><sub>f</sub> (trail_pol &#119964;) &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>defined_atm_pol</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(defined_atm_pol x1g x2f, defined_lit x1a (Pos x2)) &#8712; Id&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case y of (x, xa) &#8658; (case x of (M, L) &#8658; &#955;_. L &#8712;# &#119964;) xa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 = (x1a, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2d = (x1e, x2e)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2c = (x1d, x2d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2b = (x1c, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2a = (x1b, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y = (x1, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1f = (x1g, x2f)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2j = (x1k, x2k)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2i = (x1j, x2j)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2h = (x1i, x2i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2g = (x1h, x2h)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1f, x2g)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>x1f</span><span> </span><span>x1g</span><span> </span><span>x2f</span><span> </span><span>x2g</span><span> </span><span>x1h</span><span> </span><span>x2h</span><span>
</span><span>       </span><span>x1i</span><span> </span><span>x2i</span><span> </span><span>x1j</span><span> </span><span>x2j</span><span> </span><span>x1k</span><span> </span><span>x2k</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit x1a (Pos x2) &#10231; defined_atm x1a x2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span> </span><span>trail_pol_def</span><span> </span><span>defined_atm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undefined_atm_code</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>uncurry_def</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>&#119964;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x1a, x2)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x1g, x2f)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span> </span><span>RETURN_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_enqueue_def</span><span> </span><span>vmtf_enqueue_alt_def</span><span> </span><span>uncurry_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>defined_atm_pol_pre</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>defined_atm_pol</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>same_in_Id_option_rel</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>x1f</span><span> </span><span>x1g</span><span> </span><span>x2f</span><span> </span><span>x2g</span><span> </span><span>x1h</span><span> </span><span>x2h</span><span>
</span><span>	 </span><span>x1i</span><span> </span><span>x2i</span><span> </span><span>x1j</span><span> </span><span>x2j</span><span> </span><span>x1k</span><span> </span><span>x2k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partition_vmtf_nth</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_vmtf_node list  &#8658;  nat &#8658; nat &#8658; nat list &#8658; (nat list &#215; nat) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;partition_vmtf_nth ns = partition_main (&#8804;) (&#955;n. stamp (ns ! n))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partition_between_ref_vmtf</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_vmtf_node list &#8658;  nat &#8658; nat &#8658; nat list &#8658; (nat list &#215; nat) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;partition_between_ref_vmtf ns = partition_between_ref (&#8804;) (&#955;n. stamp (ns ! n))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>quicksort_vmtf_nth</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_vmtf_node list &#215; &#39;c &#8658; nat list &#8658; nat list nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;quicksort_vmtf_nth = (&#955;(ns, _). full_quicksort_ref (&#8804;) (&#955;n. stamp (ns ! n)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>quicksort_vmtf_nth_ref</span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_vmtf_node list &#8658; nat &#8658; nat &#8658; nat list &#8658; nat list nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;quicksort_vmtf_nth_ref ns a b c =
     quicksort_ref (&#8804;) (&#955;n. stamp (ns ! n)) (a, b, c)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>partition_vmtf_nth_code_helper</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set ba. x &lt; length a&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &lt; length ba&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>mset</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset ba = mset a2&#39;&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a1&#39; &lt; length a2&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a2&#39; ! b &lt; length a&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_mem</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>a2&#39;</span><span class="delimiter">]</span><span> </span><span>mset_eq_setD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mset</span><span class="delimiter">]</span><span> </span><span>mset_eq_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mset</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partition_vmtf_nth_code_helper3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set b. x &lt; length a &#10233;
       x&#39;e &lt; length a2&#39; &#10233;
       mset a2&#39; = mset b &#10233;
       a2&#39; ! x&#39;e &lt; length a&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_eq_setD</span><span> </span><span>nth_mem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>isa_vmtf_en_dequeue</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat &#8658; vmtf &#8658; vmtf nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue = (&#955;M L vm. isa_vmtf_enqueue M L (vmtf_dequeue L vm))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_en_dequeue</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 isa_vmtf_en_dequeue, uncurry2 (RETURN ooo vmtf_en_dequeue)) &#8712;
     [&#955;((M, L), _). L &#8712;# &#119964;]<span class="hidden">&#8681;</span><sub>f</sub> (trail_pol &#119964;) &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_en_dequeue_def</span><span> </span><span>vmtf_en_dequeue_def</span><span> </span><span>uncurry_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>aa</span><span> </span><span>ab</span><span> </span><span>ac</span><span> </span><span>ad</span><span> </span><span>b</span><span> </span><span>ba</span><span> </span><span>ae</span><span> </span><span>af</span><span> </span><span>ag</span><span> </span><span>ah</span><span> </span><span>bb</span><span> </span><span>ai</span><span> </span><span>bc</span><span> </span><span>aj</span><span> </span><span>ak</span><span> </span><span>al</span><span> </span><span>am</span><span> </span><span>bd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>isa_vmtf_enqueue</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_curry2</span><span class="delimiter">,</span><span>
</span><span>        </span><span>of</span><span> </span><span>ai</span><span> </span><span>bc</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_dequeue bc (aj, ak, al, am, bd)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_en_dequeue_pre</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(trail_pol &#215; nat) &#215; vmtf &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue_pre = (&#955;((M, L),(ns,m,fst_As, lst_As, next_search)).
       L &lt; length ns &#8743; vmtf_dequeue_pre (L, ns) &#8743;
       fst_As &lt; length ns &#8743; (get_next (ns ! fst_As) &#8800; None &#10230; get_prev (ns ! lst_As) &#8800; None) &#8743;
       (get_next (ns ! fst_As) = None &#10230; fst_As = lst_As) &#8743;
       m+1 &#8804; uint64_max)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_en_dequeue_preD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue_pre ((M, ah), a, aa, ab, ac, b)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ah &lt; length a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_dequeue_pre (ah, a)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_en_dequeue_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_en_dequeue_pre_vmtf_enqueue_pre</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue_pre ((M, L), a, st, fst_As, lst_As, next_search) &#10233;
       vmtf_enqueue_pre ((M, L), vmtf_dequeue L (a, st, fst_As, lst_As, next_search))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_enqueue_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_dequeue_pre_def</span><span> </span><span>vmtf_enqueue_pre_def</span><span> </span><span>vmtf_dequeue_def</span><span>
</span><span>        </span><span>ns_vmtf_dequeue_def</span><span> </span><span>Let_def</span><span> </span><span>isa_vmtf_en_dequeue_pre_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_dequeue_pre_def</span><span> </span><span>vmtf_enqueue_pre_def</span><span> </span><span>vmtf_dequeue_def</span><span>
</span><span>          </span><span>isa_vmtf_en_dequeue_pre_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_dequeue_pre_def</span><span> </span><span>vmtf_enqueue_pre_def</span><span> </span><span>vmtf_dequeue_def</span><span>
</span><span>        </span><span>Let_def</span><span> </span><span>isa_vmtf_en_dequeue_pre_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_dequeue_pre_def</span><span> </span><span>vmtf_enqueue_pre_def</span><span> </span><span>vmtf_dequeue_def</span><span>
</span><span>        </span><span>Let_def</span><span> </span><span>isa_vmtf_en_dequeue_pre_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_sort_reorder_list</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896; x y z. &#10214;R (h x) (h y); R (h y) (h z)&#10215; &#10233; R (h x) (h z)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;x y. R (h x) (h y) &#8744; R (h y) (h x)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(full_quicksort_ref R h, reorder_list vm) &#8712; &#10216;Id&#10217;list_rel &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;Id&#10217; nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>full_quicksort_ref_full_quicksort</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reorder_list_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>full_quicksort_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>quicksort_vmtf_nth_reorder</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry quicksort_vmtf_nth, uncurry reorder_list) &#8712;
      Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> &#10216;Id&#10217;list_rel &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;Id&#10217; nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>WB_More_Refinement.frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_sort_reorder_list</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fref_def</span><span> </span><span>nres_rel_def</span><span class="delimiter">,</span><span> </span><span>of</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8804;)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;n. stamp (fst (fst y) ! n) :: nat)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst y&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>quicksort_vmtf_nth_def</span><span> </span><span>uncurry_def</span><span> </span><span>WB_More_Refinement.fref_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atoms_hash_del_op_set_delete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (RETURN oo atoms_hash_del),
    uncurry (RETURN oo Set.remove)) &#8712;
     nat_rel &#215;<span class="hidden">&#8681;</span><sub>r</sub> atoms_hash_rel &#119964; &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;atoms_hash_rel &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atoms_hash_del_def</span><span> </span><span>atoms_hash_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>current_stamp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;current_stamp vm  = fst (snd vm)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>current_stamp_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;current_stamp = (&#955;(_, m, _). m)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>current_stamp_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_rescale_alt_def</span><span class="delimiter">:</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_rescale = (&#955;(ns, m, fst_As, lst_As :: nat, next_search). do {
    (ns, m, _) &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;_. True<span class="hidden">&#8662;</span></sup>
      (&#955;(ns, n, lst_As). lst_As &#8800;None)
      (&#955;(ns, n, a). do {
         ASSERT(a &#8800; None);
         ASSERT(n+1 &#8804; uint32_max);
         ASSERT(the a &lt; length ns);
         let m = the a;
         let c = ns ! m;
         let nc = get_next c;
         let pc = get_prev c;
         RETURN (ns[m := VMTF_Node n pc nc], n + 1, pc)
      })
      (ns, 0, Some lst_As);
    RETURN ((ns, m, fst_As, lst_As, next_search))
  })&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update_stamp.simps</span><span> </span><span>Let_def</span><span> </span><span>vmtf_rescale_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_reorder_list_raw</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_reorder_list_raw = (&#955;vm to_remove. do {
    ASSERT(&#8704;x&#8712;set to_remove. x &lt; length vm);
    reorder_list vm to_remove
  })&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_reorder_list</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_reorder_list = (&#955;(vm, _) to_remove. do {
    vmtf_reorder_list_raw vm to_remove
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_flush_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; _ &#8658; _ nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_flush_int  = (&#955;M (vm, (to_remove, h)). do {
    ASSERT(&#8704;x&#8712;set to_remove. x &lt; length (fst vm));
    ASSERT(length to_remove &#8804; uint32_max);
    to_remove&#39; &#8592; vmtf_reorder_list vm to_remove;
    ASSERT(length to_remove&#39; &#8804; uint32_max);
    vm &#8592; (if length to_remove&#39; &#8805; uint64_max - fst (snd vm)
      then vmtf_rescale vm else RETURN vm);
    ASSERT(length to_remove&#39; + fst (snd vm) &#8804; uint64_max);
    (_, vm, h) &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(i, vm&#39;, h). i &#8804; length to_remove&#39; &#8743; fst (snd vm&#39;) = i + fst (snd vm) &#8743;
          (i &lt; length to_remove&#39; &#10230; isa_vmtf_en_dequeue_pre ((M, to_remove&#39;!i), vm&#39;))<span class="hidden">&#8662;</span></sup>
      (&#955;(i, vm, h). i &lt; length to_remove&#39;)
      (&#955;(i, vm, h). do {
         ASSERT(i &lt; length to_remove&#39;);
	 ASSERT(isa_vmtf_en_dequeue_pre ((M, to_remove&#39;!i), vm));
         vm &#8592; isa_vmtf_en_dequeue M (to_remove&#39;!i) vm;
	 ASSERT(atoms_hash_del_pre (to_remove&#39;!i) h);
         RETURN (i+1, vm, atoms_hash_del (to_remove&#39;!i) h)})
      (0, vm, h);
    RETURN (vm, (emptied_list to_remove&#39;, h))
  })&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_flush_int</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry isa_vmtf_flush_int, uncurry (vmtf_flush_int &#119964;)) &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vmtf_flush_int_alt_def</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_flush_int &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> = (&#955;M (vm, (to_remove, h)). do {
      ASSERT(&#8704;x&#8712;set to_remove. x &lt; length (fst vm));
      ASSERT(length to_remove &#8804; uint32_max);
      to_remove&#39; &#8592; reorder_list vm to_remove;
      ASSERT(length to_remove&#39; &#8804; uint32_max);
      vm &#8592; (if length to_remove&#39; + fst (snd vm) &#8805; uint64_max
	then vmtf_rescale vm else RETURN vm);
      ASSERT(length to_remove&#39; + fst (snd vm) &#8804; uint64_max);
      (_, vm, h) &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(i, vm&#39;, h). i &#8804; length to_remove&#39; &#8743; fst (snd vm&#39;) = i + fst (snd vm) &#8743;
	    (i &lt; length to_remove&#39; &#10230; vmtf_en_dequeue_pre &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> ((M, to_remove&#39;!i), vm&#39;))<span class="hidden">&#8662;</span></sup>
	(&#955;(i, vm, h). i &lt; length to_remove&#39;)
	(&#955;(i, vm, h). do {
	   ASSERT(i &lt; length to_remove&#39;);
	   ASSERT(to_remove&#39;!i &#8712;# &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>);
	   ASSERT(atoms_hash_del_pre (to_remove&#39;!i) h);
	   vm &#8592; RETURN(vmtf_en_dequeue M (to_remove&#39;!i) vm);
	   RETURN (i+1, vm, atoms_hash_del (to_remove&#39;!i) h)})
	(0, vm, h);
      RETURN (vm, (emptied_list to_remove&#39;, h))
    })&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_flush_int_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reorder_list</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_reorder_list x1d x1e
	&#8804; &#8659; Id
	   (reorder_list x1a x1b)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2a = (x1b, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = (x1a, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2d = (x1e, x2e)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2c = (x1d, x2d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1c, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1b. x &lt; length (fst x1a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1b &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1e. x &lt; length (fst x1d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1e &#8804; uint32_max&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_reorder_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x1a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reorder_list_def</span><span> </span><span>vmtf_reorder_list_raw_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vmtf_rescale</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_rescale x1d
	&#8804; &#8659; Id
	   (vmtf_rescale x1a)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2a = (x1b, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = (x1a, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2d = (x1e, x2e)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2c = (x1d, x2d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1c, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1b. x &lt; length (fst x1a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1b &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1e. x &lt; length (fst x1d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1e &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(to_remove&#39;, to_remove&#39;a) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39;a &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39; &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint64_max &#8804; length to_remove&#39;a + fst (snd x1a)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>to_remove&#39;</span><span> </span><span>to_remove&#39;a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>loop_rel</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((0, vm, x2e), 0, vma, x2b) &#8712; Id&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2a = (x1b, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = (x1a, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2d = (x1e, x2e)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2c = (x1d, x2d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1c, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1b. x &lt; length (fst x1a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1b &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1e. x &lt; length (fst x1d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1e &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(to_remove&#39;, to_remove&#39;a) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39;a &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39; &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(vm, vma) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39;a + fst (snd vma) &#8804; uint64_max&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case (0, vma, x2b) of
       (i, vm&#39;, h) &#8658;
	 i &#8804; length to_remove&#39;a &#8743;
	 fst (snd vm&#39;) = i + fst (snd vma) &#8743;
	 (i &lt; length to_remove&#39;a &#10230;
	  vmtf_en_dequeue_pre &#119964; ((x1, to_remove&#39;a ! i), vm&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>to_remove&#39;</span><span> </span><span>to_remove&#39;a</span><span> </span><span>vm</span><span>
</span><span>       </span><span>vma</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isa_vmtf_en_dequeue_pre</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_en_dequeue_pre &#119964; ((M, L), x) &#10233; isa_vmtf_en_dequeue_pre ((M&#39;, L), x)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>M</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_en_dequeue_pre_def</span><span> </span><span>isa_vmtf_en_dequeue_pre_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isa_vmtf_en_dequeue</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue x1c (to_remove&#39; ! x1h) x1i
       &#8804; SPEC
	  (&#955;c. (c, vmtf_en_dequeue x1 (to_remove&#39;a ! x1f) x1g)
	       &#8712; Id)&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1b. x &lt; length (fst x1a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1b &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;x&#8712;set x1e. x &lt; length (fst x1d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length x1e &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39;a &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39; &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length to_remove&#39;a + fst (snd vma) &#8804; uint64_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case xa of (i, vm, h) &#8658; i &lt; length to_remove&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x&#39; of (i, vm, h) &#8658; i &lt; length to_remove&#39;a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case xa of
      (i, vm&#39;, h) &#8658;
	i &#8804; length to_remove&#39; &#8743;
	fst (snd vm&#39;) = i + fst (snd vm) &#8743;
	(i &lt; length to_remove&#39; &#10230;
	 isa_vmtf_en_dequeue_pre ((x1c, to_remove&#39; ! i), vm&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x&#39; of
      (i, vm&#39;, h) &#8658;
	i &#8804; length to_remove&#39;a &#8743;
	fst (snd vm&#39;) = i + fst (snd vma) &#8743;
	(i &lt; length to_remove&#39;a &#10230;
	 vmtf_en_dequeue_pre &#119964; ((x1, to_remove&#39;a ! i), vm&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue_pre ((x1c, to_remove&#39; ! x1h), x1i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1f &lt; length to_remove&#39;a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;to_remove&#39;a ! x1f &#8712;# &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1h &lt; length to_remove&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2a = (x1b, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = (x1a, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1c, x2c)&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2d = (x1e, x2e)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2c = (x1d, x2d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2f = (x1g, x2g)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#39; = (x1f, x2f)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2h = (x1i, x2i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa = (x1h, x2h)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(to_remove&#39;, to_remove&#39;a) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(xa, x&#39;) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(vm, vma) &#8712; Id&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>to_remove&#39;</span><span> </span><span>to_remove&#39;a</span><span> </span><span>vm</span><span>
</span><span>       </span><span>vma</span><span> </span><span>xa</span><span> </span><span>x&#39;</span><span> </span><span>x1f</span><span> </span><span>x2f</span><span> </span><span>x1g</span><span> </span><span>x2g</span><span> </span><span>x1h</span><span> </span><span>x2h</span><span> </span><span>x1i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x2i</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bool list&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isa_vmtf_en_dequeue</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_curry2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;to_remove&#39;a ! x1f&#8250;</span></span></span><span> </span><span>x1g</span><span>
</span><span>     </span><span>x1c</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;to_remove&#39; ! x1h&#8250;</span></span></span><span> </span><span>x1i</span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RETURN_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_flush_int_def</span><span> </span><span>uncurry_def</span><span> </span><span>vmtf_flush_int_alt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reorder_list</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vmtf_rescale</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>loop_rel</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_en_dequeue_pre</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isa_vmtf_en_dequeue</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>to_remove&#39;</span><span> </span><span>to_remove&#39;a</span><span> </span><span>vm</span><span>
</span><span>       </span><span>vma</span><span> </span><span>xa</span><span> </span><span>x&#39;</span><span> </span><span>x1f</span><span> </span><span>x2f</span><span> </span><span>x1g</span><span> </span><span>x2g</span><span> </span><span>x1h</span><span> </span><span>x2h</span><span> </span><span>x1i</span><span> </span><span>x2i</span><span> </span><span>vmb</span><span> </span><span>vmc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>atms_hash_insert_pre</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; nat list &#215; bool list &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_hash_insert_pre i = (&#955;(n, xs). i &lt; length xs &#8743; (&#172;xs!i &#10230; length n &lt; 2 + uint32_max div 2))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>atoms_hash_insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; nat list &#215; bool list &#8658; (nat list &#215; bool list)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atoms_hash_insert i  = (&#955;(n, xs). if xs ! i then (n, xs) else (n @ [i], xs[i := True]))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_included_le</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set n &#8838; set_mset &#119964; &#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length n &lt; uint32_max&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length n &#8804; 1 + uint32_max div 2&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lits</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (Pos `# mset n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_alt_def</span><span> </span><span>distinct_atoms_rel_alt_def</span><span> </span><span>inj_on_def</span><span> </span><span>atms_of_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (Pos `# mset n)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>dist</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: inj_on_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tauto</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; tautology (poss (mset n))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tautology_decomp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length n &lt; uint32_max&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length n &#8804; 1 + uint32_max div 2&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_clss_size_upper_div2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bounded</span><span> </span><span>lits</span><span> </span><span>dist</span><span> </span><span>tauto</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint32_max_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atms_hash_insert_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, x&#39;) &#8712; distinct_atoms_rel &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_hash_insert_pre L x&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>bounded_included_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L # fst x&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>atoms_hash_insert_def</span><span> </span><span>atoms_hash_rel_def</span><span> </span><span>distinct_atoms_rel_alt_def</span><span>
</span><span>     </span><span>atms_hash_insert_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atoms_hash_del_op_set_insert</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (RETURN oo atoms_hash_insert),
    uncurry (RETURN oo insert)) &#8712;
     [&#955;(i, xs). i &#8712;# &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; isasat_input_bounded &#119964;]<span class="hidden">&#8681;</span><sub>f</sub>
     nat_rel &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8594; &#10216;distinct_atoms_rel &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atoms_hash_insert_def</span><span> </span><span>atoms_hash_rel_def</span><span> </span><span>distinct_atoms_rel_alt_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>atoms_hash_set_member</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atoms_hash_set_member i xs =  do {ASSERT(i &lt; length xs); RETURN (xs ! i)}&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_mark_to_rescore</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; isa_vmtf_remove_int &#8658; isa_vmtf_remove_int&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_mark_to_rescore L = (&#955;((ns, m, fst_As, next_search), to_remove).
     ((ns, m, fst_As, next_search), atoms_hash_insert L to_remove))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_mark_to_rescore_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_mark_to_rescore_pre = (&#955;L ((ns, m, fst_As, next_search), to_remove).
     atms_hash_insert_pre L to_remove)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_mark_to_rescore_vmtf_mark_to_rescore</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (RETURN oo isa_vmtf_mark_to_rescore), uncurry (RETURN oo vmtf_mark_to_rescore)) &#8712;
      [&#955;(L, vm). L&#8712;# &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; isasat_input_bounded &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>]<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>) &#8594;
      &#10216;Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_def</span><span> </span><span>vmtf_mark_to_rescore_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>atoms_hash_del_op_set_insert</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>isa_vmtf_unset</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; isa_vmtf_remove_int &#8658; isa_vmtf_remove_int&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_unset = (&#955;L ((ns, m, fst_As, lst_As, next_search), to_remove).
  (if next_search = None &#8744; stamp (ns ! (the next_search)) &lt; stamp (ns ! L)
  then ((ns, m, fst_As, lst_As, Some L), to_remove)
  else ((ns, m, fst_As, lst_As, next_search), to_remove)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_unset_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_unset_pre = (&#955;L ((ns, m, fst_As, lst_As, next_search), to_remove).
  L &lt; length ns &#8743; (next_search &#8800; None &#10230; the next_search &lt; length ns))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_unset_pre_vmtf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((ns, m, fst_As, lst_As, next_search), to_remove) &#8712; vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_unset_pre L ((ns, m, fst_As, lst_As, next_search), to_remove)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_def</span><span> </span><span>vmtf_unset_pre_def</span><span> </span><span>atms_of_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_unset_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((ns, m, fst_As, lst_As, next_search), to_remove) &#8712; isa_vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_unset_pre L ((ns, m, fst_As, lst_As, next_search), to_remove)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>vmtf_unset_pre_vmtf</span><span class="delimiter">[</span><span>of</span><span> </span><span>ns</span><span> </span><span>m</span><span> </span><span>fst_As</span><span> </span><span>lst_As</span><span> </span><span>next_search</span><span> </span><span>_</span><span> </span><span>&#119964;</span><span> </span><span>M</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_def</span><span> </span><span>vmtf_unset_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_unset_pre&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; isa_vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_unset_pre L vm&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>vmtf_unset_pre</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_mark_to_rescore_and_unset</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; isa_vmtf_remove_int &#8658; isa_vmtf_remove_int&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_mark_to_rescore_and_unset L M = isa_vmtf_mark_to_rescore L (isa_vmtf_unset L M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_mark_to_rescore_and_unset_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_mark_to_rescore_and_unset_pre = (&#955;(L, ((ns, m, fst_As, lst_As, next_search), tor)).
      vmtf_unset_pre L ((ns, m, fst_As, lst_As, next_search), tor) &#8743;
      atms_hash_insert_pre L tor)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_conflict_int_size_conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o size_conflict_int, RETURN o size_conflict) &#8712; [&#955;D. D &#8800; None]<span class="hidden">&#8681;</span><sub>f</sub> option_lookup_clause_rel &#119964; &#8594;
     &#10216;nat_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_conflict_int_def</span><span> </span><span>size_conflict_def</span><span> </span><span>option_lookup_clause_rel_def</span><span>
</span><span>      </span><span>lookup_clause_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rescore_clause</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset &#8658; nat clause_l &#8658; (nat,nat)ann_lits &#8658; vmtf_remove_int &#8658;
    (vmtf_remove_int) nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rescore_clause &#119964; C M vm = SPEC (&#955;(vm&#39;). vm&#39; &#8712; vmtf &#119964; M)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_unset_vmtf_unset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (RETURN oo isa_vmtf_unset), uncurry (RETURN oo vmtf_unset)) &#8712;
     nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;) &#8594;<span class="hidden">&#8681;</span><sub>f</sub>
     &#10216;(Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;)&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_unset_def</span><span> </span><span>isa_vmtf_unset_def</span><span> </span><span>uncurry_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_unset_isa_vmtf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; isa_vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_unset L vm &#8712; isa_vmtf &#119964; M&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vm0</span><span> </span><span>to_remove</span><span> </span><span>to_remove&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>vm</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm = (vm0, to_remove)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>vm0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(vm0, to_remove&#39;) &#8712; vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(to_remove, to_remove&#39;) &#8712; distinct_atoms_rel &#119964;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span>isa_vmtf_unset_vmtf_unset</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>L</span><span> </span><span>vm</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(vm0, to_remove&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>abs_vmtf_ns_unset_vmtf_unset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst vm0&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd vm0)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd (snd vm0))&#8250;</span></span></span><span>
</span><span>         </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd (snd (snd vm0)))&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd (snd (snd vm0)))&#8250;</span></span></span><span> </span><span>to_remove&#39;</span><span> </span><span>&#119964;</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>to_remove&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vm</span><span> </span><span>atms_of_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isa_vmtfI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prod_relE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_tl_isa_vmtf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; isa_vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8800; []&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (hd M) &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = (atm_of (lit_of (hd M)))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_unset L vm &#8712; isa_vmtf &#119964; (tl M)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?L</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of (lit_of (hd M))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vm0</span><span> </span><span>to_remove</span><span> </span><span>to_remove&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>vm</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm = (vm0, to_remove)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>vm0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(vm0, to_remove&#39;) &#8712; vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(to_remove, to_remove&#39;) &#8712; distinct_atoms_rel &#119964;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span>isa_vmtf_unset_vmtf_unset</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?L</span><span> </span><span>vm</span><span> </span><span class="var">?L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(vm0, to_remove&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>vmtf_unset_vmtf_tl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst vm0&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd vm0)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd (snd vm0))&#8250;</span></span></span><span>
</span><span>         </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd (snd (snd vm0)))&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd (snd (snd vm0)))&#8250;</span></span></span><span> </span><span>to_remove&#39;</span><span> </span><span>&#119964;</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vm</span><span> </span><span>atms_of_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isa_vmtfI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prod_relE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_find_next_undef</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_remove_int &#8658; trail_pol &#8658; (nat option) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_find_next_undef = (&#955;((ns, m, fst_As, lst_As, next_search), to_remove) M. do {
    WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;next_search. next_search &#8800; None &#10230; defined_atm_pol_pre M (the next_search)<span class="hidden">&#8662;</span></sup>
      (&#955;next_search. next_search &#8800; None &#8743; defined_atm_pol M (the next_search))
      (&#955;next_search. do {
         ASSERT(next_search &#8800; None);
         let n = the next_search;
         ASSERT (n &lt; length ns);
         RETURN (get_next (ns!n))
        }
      )
      next_search
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_find_next_undef_vmtf_find_next_undef</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry isa_vmtf_find_next_undef, uncurry (vmtf_find_next_undef &#119964;)) &#8712;
      (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;) &#215;<span class="hidden">&#8681;</span><sub>r</sub> trail_pol &#119964;  &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;&#10216;nat_rel&#10217;option_rel&#10217;nres_rel &#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_find_next_undef_def</span><span> </span><span>vmtf_find_next_undef_def</span><span> </span><span>uncurry_def</span><span>
</span><span>    </span><span>defined_atm_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>defined_atm_pol_pre</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>undefined_atm_code</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry_Id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bumping&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_rescore_body</span><span>
</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset &#8658; nat clause_l &#8658; (nat,nat) ann_lits &#8658; vmtf_remove_int &#8658;
    (nat &#215; vmtf_remove_int) nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_rescore_body &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> C _ vm = do {
         WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(i, vm). i &#8804; length C  &#8743;
            (&#8704;c &#8712; set C. atm_of c &lt; length (fst (fst vm)))<span class="hidden">&#8662;</span></sup>
           (&#955;(i, vm). i &lt; length C)
           (&#955;(i, vm). do {
               ASSERT(i &lt; length C);
               ASSERT(atm_of (C!i) &#8712;# &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>);
               let vm&#39; = vmtf_mark_to_rescore (atm_of (C!i)) vm;
               RETURN(i+1, vm&#39;)
             })
           (0, vm)
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_rescore</span><span>
</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset &#8658; nat clause_l &#8658; (nat,nat) ann_lits &#8658; vmtf_remove_int &#8658;
       (vmtf_remove_int) nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_rescore &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> C M vm = do {
      (_, vm) &#8592; vmtf_rescore_body &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> C M vm;
      RETURN (vm)
   }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>isa_vmtf_mark_to_rescore</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_rescore_body</span><span>
</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clause_l &#8658; trail_pol &#8658; isa_vmtf_remove_int &#8658;
    (nat &#215; isa_vmtf_remove_int) nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_rescore_body C _ vm = do {
         WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(i, vm). i &#8804; length C  &#8743;
            (&#8704;c &#8712; set C. atm_of c &lt; length (fst (fst vm)))<span class="hidden">&#8662;</span></sup>
           (&#955;(i, vm). i &lt; length C)
           (&#955;(i, vm). do {
               ASSERT(i &lt; length C);
               ASSERT(isa_vmtf_mark_to_rescore_pre (atm_of (C!i)) vm);
               let vm&#39; = isa_vmtf_mark_to_rescore (atm_of (C!i)) vm;
               RETURN(i+1, vm&#39;)
             })
           (0, vm)
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_rescore</span><span>
</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clause_l &#8658; trail_pol &#8658; isa_vmtf_remove_int &#8658;
       (isa_vmtf_remove_int) nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_rescore C M vm = do {
      (_, vm) &#8592; isa_vmtf_rescore_body C M vm;
      RETURN (vm)
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_rescore_score_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 (vmtf_rescore &#119964;), uncurry2 (rescore_clause &#119964;)) &#8712;
     [&#955;((C, M), vm). literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (mset C) &#8743; vm &#8712; vmtf &#119964; M]<span class="hidden">&#8681;</span><sub>f</sub>
     (&#10216;Id&#10217;list_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id) &#8594; &#10216;Id&#10217; nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_rescore_body &#119964; C M vm &#8804;
        SPEC (&#955;(n :: nat, vm&#39;).  vm&#39; &#8712; vmtf &#119964; M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; vmtf &#119964; M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;c&#8712;set C. atm_of c &#8712; atms_of (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>vm</span><span> </span><span>&#966;</span><span> </span><span>M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_rescore_body_def</span><span> </span><span>vmtf_mark_to_rescore_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>WHILEIT_rule_stronger_inv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;measure (&#955;(i, _). length C - i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>I&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;(i, vm&#39;). vm&#39; &#8712; vmtf &#119964; M&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_def</span><span> </span><span>phase_saving_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atms_of_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_append_remove_iff&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((a, b),(a&#39;, b&#39;)) &#8712; A &#215;<span class="hidden">&#8681;</span><sub>f</sub> B &#10231; (a, a&#39;) &#8712; A &#8743; (b, b&#39;) &#8712; B&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span> </span><span>A</span><span> </span><span>B</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_rescore_def</span><span> </span><span>rescore_clause_def</span><span> </span><span>uncurry_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bind_refine_spec</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>atm_of_lit_in_atms_of</span><span> </span><span>contra_subsetD</span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span>
</span><span>          </span><span>in_multiset_in_set</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_rescore_body</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 (isa_vmtf_rescore_body), uncurry2 (vmtf_rescore_body &#119964;)) &#8712; [&#955;_. isasat_input_bounded &#119964;]<span class="hidden">&#8681;</span><sub>f</sub>
     (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964;)) &#8594; &#10216;Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964;)&#10217; nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_rescore_body_def</span><span> </span><span>vmtf_rescore_body_def</span><span> </span><span>uncurry_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x1b</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x1d</span><span> </span><span>x1e</span><span> </span><span>x2c</span><span> </span><span>x1g</span><span> </span><span>x2g</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x2g</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x1b</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x1d</span><span> </span><span>x1e</span><span> </span><span>x2c</span><span> </span><span>x2d</span><span> </span><span>x2e</span><span> </span><span>x1g</span><span> </span><span>x2g</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_pre_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x2e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>atms_hash_insert_pre</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>  </span><span>isa_vmtf_mark_to_rescore_vmtf_mark_to_rescore</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_rescore</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 (isa_vmtf_rescore), uncurry2 (vmtf_rescore &#119964;)) &#8712; [&#955;_. isasat_input_bounded &#119964;]<span class="hidden">&#8681;</span><sub>f</sub>
     (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964;)) &#8594; &#10216;(Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964;)&#10217; nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_rescore_def</span><span> </span><span>vmtf_rescore_def</span><span> </span><span>uncurry_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>isa_vmtf_rescore_body</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_curry2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO use in vmtf_mark_to_rescore_and_unset *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_mark_to_rescore_clause</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_mark_to_rescore_clause &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> arena C vm = do {
    ASSERT(arena_is_valid_clause_idx arena C);
    nfoldli
      ([C..&lt;C + (arena_length arena C)])
      (&#955;_. True)
      (&#955;i vm. do {
        ASSERT(i &lt; length arena);
        ASSERT(arena_lit_pre arena i);
        ASSERT(atm_of (arena_lit arena i) &#8712;# &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>);
        RETURN (vmtf_mark_to_rescore (atm_of (arena_lit arena i)) vm)
      })
      vm
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_mark_to_rescore_clause</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_mark_to_rescore_clause arena C vm = do {
    ASSERT(arena_is_valid_clause_idx arena C);
    nfoldli
      ([C..&lt;C + (arena_length arena C)])
      (&#955;_. True)
      (&#955;i vm. do {
        ASSERT(i &lt; length arena);
        ASSERT(arena_lit_pre arena i);
        ASSERT(isa_vmtf_mark_to_rescore_pre (atm_of (arena_lit arena i)) vm);
        RETURN (isa_vmtf_mark_to_rescore (atm_of (arena_lit arena i)) vm)
      })
      vm
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_mark_to_rescore_clause_vmtf_mark_to_rescore_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 isa_vmtf_mark_to_rescore_clause, uncurry2 (vmtf_mark_to_rescore_clause &#119964;)) &#8712; [&#955;_. isasat_input_bounded &#119964;]<span class="hidden">&#8681;</span><sub>f</sub>
    Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;) &#8594; &#10216;Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_clause_def</span><span> </span><span>vmtf_mark_to_rescore_clause_def</span><span>
</span><span>    </span><span>uncurry_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>nfoldli_refine</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>Id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x1c</span><span> </span><span>x2b</span><span> </span><span>x2c</span><span> </span><span>xi</span><span> </span><span>xa</span><span> </span><span>si</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_mark_to_rescore_pre_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>atms_hash_insert_pre</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isa_vmtf_mark_to_rescore_vmtf_mark_to_rescore</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_mark_to_rescore_clause_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; vmtf &#119964;  M &#10233; valid_arena arena N vdom &#10233; C &#8712;# dom_m N &#10233;
   (&#8704;C &#8712; set [C..&lt;C + arena_length arena C]. arena_lit arena C &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#10233;
    vmtf_mark_to_rescore_clause &#119964; arena C vm &#8804; RES (vmtf &#119964; M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_mark_to_rescore_clause_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RES_SPEC_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>nfoldli_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;_ _ vm. vm &#8712; vmtf &#119964; M&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arena_lit_pre_def</span><span> </span><span>arena_is_valid_clause_idx_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>N</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>vdom</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>arena_lifting</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>it</span><span> </span><span>&#963;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arena_lifting</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>arena</span><span> </span><span>N</span><span> </span><span>vdom</span><span> </span><span>C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x - C&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>arena_lifting</span><span class="delimiter">(</span><span>1</span><span>-</span><span>6</span><span class="delimiter">)</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_list_in_setD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>it</span><span> </span><span>&#963;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arena_lit_pre_def</span><span> </span><span>arena_is_valid_clause_idx_and_access_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>C</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto dest: in_list_in_setD&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>N</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>vdom</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>arena_lifting</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_list_in_setD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>it</span><span> </span><span>&#963;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>it</span><span> </span><span>_</span><span> </span><span>&#963;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>&#963;</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vmtf_mark_to_rescore</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span>
</span><span>       </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_list_in_setD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vmtf_mark_to_rescore_also_reasons</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset &#8658; (nat, nat) ann_lits &#8658; arena &#8658; nat literal list &#8658; _ &#8658;_&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_mark_to_rescore_also_reasons &#119964; M arena outl vm = do {
    ASSERT(length outl &#8804; uint32_max);
    nfoldli
      ([0..&lt;length outl])
      (&#955;_. True)
      (&#955;i vm. do {
        ASSERT(i &lt; length outl); ASSERT(length outl &#8804; uint32_max);
        ASSERT(-outl ! i &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;);
        C &#8592; get_the_propagation_reason M (-(outl ! i));
        case C of
          None &#8658; RETURN (vmtf_mark_to_rescore (atm_of (outl ! i)) vm)
        | Some C &#8658; if C = 0 then RETURN vm else vmtf_mark_to_rescore_clause &#119964; arena C vm
      })
      vm
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_vmtf_mark_to_rescore_also_reasons</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; arena &#8658; nat literal list &#8658; _ &#8658;_&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_mark_to_rescore_also_reasons M arena outl vm = do {
    ASSERT(length outl &#8804; uint32_max);
    nfoldli
      ([0..&lt;length outl])
      (&#955;_. True)
      (&#955;i vm. do {
        ASSERT(i &lt; length outl); ASSERT(length outl&#8804; uint32_max);
        C &#8592; get_the_propagation_reason_pol M (-(outl ! i));
        case C of
          None &#8658; do {
            ASSERT (isa_vmtf_mark_to_rescore_pre (atm_of (outl ! i)) vm);
            RETURN (isa_vmtf_mark_to_rescore (atm_of (outl ! i)) vm)
	  }
        | Some C &#8658; if C = 0 then RETURN vm else isa_vmtf_mark_to_rescore_clause arena C vm
      })
      vm
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_mark_to_rescore_also_reasons_vmtf_mark_to_rescore_also_reasons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry3 isa_vmtf_mark_to_rescore_also_reasons, uncurry3 (vmtf_mark_to_rescore_also_reasons &#119964;)) &#8712;
    [&#955;_. isasat_input_bounded &#119964;]<span class="hidden">&#8681;</span><sub>f</sub>
    trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;) &#8594; &#10216;Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_also_reasons_def</span><span> </span><span>vmtf_mark_to_rescore_also_reasons_def</span><span>
</span><span>    </span><span>uncurry_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>nfoldli_refine</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>Id</span><span class="delimiter">]</span><span>
</span><span>    </span><span>get_the_propagation_reason_pol</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_curry</span><span class="delimiter">]</span><span>
</span><span>     </span><span>isa_vmtf_mark_to_rescore_clause_vmtf_mark_to_rescore_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_curry2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x1b</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x1d</span><span> </span><span>x1e</span><span> </span><span>x2c</span><span> </span><span>x2d</span><span> </span><span>x2e</span><span> </span><span>xi</span><span> </span><span>xa</span><span> </span><span>si</span><span> </span><span>s</span><span> </span><span>xb</span><span> </span><span>x&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_mark_to_rescore_pre_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>atms_hash_insert_pre</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>&#119964;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isa_vmtf_mark_to_rescore_vmtf_mark_to_rescore</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_mark_to_rescore&#39;</span><span class="delimiter">:</span><span>
</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; atms_of (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#10233; vm &#8712; vmtf &#119964; M &#10233; vmtf_mark_to_rescore L vm &#8712; vmtf &#119964; M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vmtf_mark_to_rescore</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_mark_to_rescore_also_reasons_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; vmtf &#119964; M &#10233; valid_arena arena N vdom &#10233; length outl &#8804; uint32_max &#10233;
   (&#8704;L &#8712; set outl. L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#10233;
   (&#8704;L &#8712; set outl. &#8704;C. (Propagated (-L) C &#8712; set M &#10230; C &#8800; 0 &#10230; (C &#8712;# dom_m N &#8743;
       (&#8704;C &#8712; set [C..&lt;C + arena_length arena C]. arena_lit arena C &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)))) &#10233;
    vmtf_mark_to_rescore_also_reasons &#119964; M arena outl vm &#8804; RES (vmtf &#119964; M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_mark_to_rescore_also_reasons_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RES_SPEC_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>nfoldli_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;_ _ vm. vm &#8712; vmtf &#119964; M&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_list_in_setD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>l1</span><span> </span><span>l2</span><span> </span><span>&#963;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_set_conv_nth</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_list_in_setD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>l1</span><span> </span><span>l2</span><span> </span><span>&#963;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>get_the_propagation_reason_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SPEC_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>reason</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>reason</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>option.simps</span><span> </span><span>RES_SPEC_conv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vmtf_mark_to_rescore&#39;</span><span>
</span><span>        </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>D</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = 0&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vmtf_mark_to_rescore_clause_spec</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>       </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Backtrack level for Restarts&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  We here find out how many decisions can be reused. Remark that since VMTF does not reuse many levels anyway,
  the implementation might be mostly useless, but I was not aware of that when I implemented it.
&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO ded-uplicate definitions *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_decomp_w_ns_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_w_ns_pre &#119964; = (&#955;((M, highest), vm).
       no_dup M &#8743;
       highest &lt; count_decided M &#8743;
       isasat_input_bounded &#119964; &#8743;
       literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail &#119964; M &#8743;
       vm &#8712; vmtf &#119964; M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_decomp_wl_imp</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset &#8658; (nat, nat) ann_lits &#8658; nat &#8658; vmtf_remove_int &#8658;
       ((nat, nat) ann_lits &#215; vmtf_remove_int) nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_wl_imp &#119964; = (&#955;M<span class="hidden">&#8681;</span><sub>0</sub> lev vm. do {
    let k = count_decided M<span class="hidden">&#8681;</span><sub>0</sub>;
    let M<span class="hidden">&#8681;</span><sub>0</sub> = trail_conv_to_no_CS M<span class="hidden">&#8681;</span><sub>0</sub>;
    let n = length M<span class="hidden">&#8681;</span><sub>0</sub>;
    pos &#8592; get_pos_of_level_in_trail M<span class="hidden">&#8681;</span><sub>0</sub> lev;
    ASSERT((n - pos) &#8804; uint32_max);
    ASSERT(n &#8805; pos);
    let target = n - pos;
    (_, M, vm&#39;) &#8592;
       WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(j, M, vm&#39;). j &#8804; target &#8743;
           M = drop j M<span class="hidden">&#8681;</span><sub>0</sub> &#8743; target &#8804; length M<span class="hidden">&#8681;</span><sub>0</sub> &#8743;
           vm&#39; &#8712; vmtf &#119964; M &#8743; literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (lit_of `# mset M)<span class="hidden">&#8662;</span></sup>
         (&#955;(j, M, vm). j &lt; target)
         (&#955;(j, M, vm). do {
            ASSERT(M &#8800; []);
            ASSERT(Suc j &#8804; uint32_max);
            let L = atm_of (lit_of_hd_trail M);
            ASSERT(L &#8712;# &#119964;);
            RETURN (j + 1, tl M, vmtf_unset L vm)
         })
         (0, M<span class="hidden">&#8681;</span><sub>0</sub>, vm);
    ASSERT(lev = count_decided M);
    let M = trail_conv_back lev M;
    RETURN (M, vm&#39;)
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isa_find_decomp_wl_imp</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat &#8658; isa_vmtf_remove_int &#8658; (trail_pol &#215; isa_vmtf_remove_int) nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_find_decomp_wl_imp = (&#955;M<span class="hidden">&#8681;</span><sub>0</sub> lev vm. do {
    let k = count_decided_pol M<span class="hidden">&#8681;</span><sub>0</sub>;
    let M<span class="hidden">&#8681;</span><sub>0</sub> = trail_pol_conv_to_no_CS M<span class="hidden">&#8681;</span><sub>0</sub>;
    ASSERT(isa_length_trail_pre M<span class="hidden">&#8681;</span><sub>0</sub>);
    let n = isa_length_trail M<span class="hidden">&#8681;</span><sub>0</sub>;
    pos &#8592; get_pos_of_level_in_trail_imp M<span class="hidden">&#8681;</span><sub>0</sub> lev;
    ASSERT((n - pos) &#8804; uint32_max);
    ASSERT(n &#8805; pos);
    let target = n - pos;
    (_, M, vm&#39;) &#8592;
       WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(j, M, vm&#39;). j &#8804; target<span class="hidden">&#8662;</span></sup>
         (&#955;(j, M, vm). j &lt; target)
         (&#955;(j, M, vm). do {
            ASSERT(Suc j &#8804; uint32_max);
            ASSERT(case M of (M, _) &#8658; M &#8800; []);
            ASSERT(tl_trailt_tr_no_CS_pre M);
            let L = atm_of (lit_of_last_trail_pol M);
            ASSERT(vmtf_unset_pre L vm);
            RETURN (j + 1, tl_trailt_tr_no_CS M, isa_vmtf_unset L vm)
         })
         (0, M<span class="hidden">&#8681;</span><sub>0</sub>, vm);
    M &#8592; trail_conv_back_imp lev M;
    RETURN (M, vm&#39;)
  })&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>find_decomp_w_ns_prop</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_w_ns_prop &#119964; &#8801;
     (&#955;(M::(nat, nat) ann_lits) highest _.
        (&#955;(M1, vm). &#8707;K M2. (Decided K # M1, M2) &#8712; set (get_all_ann_decomposition M) &#8743;
          get_level M K = Suc highest &#8743; vm &#8712; vmtf &#119964; M1))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_decomp_w_ns</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_w_ns &#119964; =
     (&#955;(M::(nat, nat) ann_lits) highest vm.
        SPEC(find_decomp_w_ns_prop &#119964; M highest vm))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_find_decomp_wl_imp_find_decomp_wl_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 isa_find_decomp_wl_imp, uncurry2 (find_decomp_wl_imp &#119964;)) &#8712;
     [&#955;((M, lev), vm). lev &lt; count_decided M]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;) &#8594;
     &#10216;trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>r</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;)&#10217;nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964; &#10233;  (M&#39;, M) &#8712; trail_pol_no_CS &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M&#39;</span><span> </span><span>M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>control_stack_length_count_dec</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine0</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((0, trail_pol_conv_to_no_CS x1c, x2c),
        0, trail_conv_to_no_CS x1a, x2a)
        &#8712; nat_rel &#215;<span class="hidden">&#8681;</span><sub>r</sub> trail_pol_no_CS &#119964; &#215;<span class="hidden">&#8681;</span><sub>r</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> distinct_atoms_rel &#119964;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case y of
       (x, xa) &#8658; (case x of (M, lev) &#8658; &#955;_. lev &lt; count_decided M) xa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y)
       &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 = (x1a, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y = (x1, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1b = (x1c, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1b, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_length_trail_pre (trail_pol_conv_to_no_CS x1c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(pos, posa) &#8712; nat_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail_conv_to_no_CS x1a) - posa &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_length_trail (trail_pol_conv_to_no_CS x1c) - pos &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case (0, trail_conv_to_no_CS x1a, x2a) of
       (j, M, vm&#39;) &#8658;
         j &#8804; length (trail_conv_to_no_CS x1a) - posa &#8743;
         M = drop j (trail_conv_to_no_CS x1a) &#8743;
         length (trail_conv_to_no_CS x1a) - posa
         &#8804; length (trail_conv_to_no_CS x1a) &#8743;
         vm&#39; &#8712; vmtf &#119964; M &#8743; literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (lit_of `# mset M)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x1c</span><span> </span><span>x2b</span><span> </span><span>x2c</span><span> </span><span>pos</span><span> </span><span>posa</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>trail_pol_conv_to_no_CS_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>trail_conv_to_no_CS_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trail_pol_empty</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(([], x2g), M) &#8712; trail_pol_no_CS &#119964; &#10233; M = []&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>x2g</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>ann_lits_split_reasons_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isa_vmtf</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x2c, x2a) &#8712; Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964; &#10233;
       (((aa, ab, ac, ad, ba), baa, ca), x2e) &#8712; Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964; &#10233;
       x2e &#8712; vmtf &#119964; (drop x1d x1a) &#10233;
       ((aa, ab, ac, ad, ba), baa, ca) &#8712; isa_vmtf &#119964; (drop x1d x1a)&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x1c</span><span> </span><span>x2b</span><span> </span><span>x2c</span><span> </span><span>pos</span><span> </span><span>posa</span><span> </span><span>xa</span><span> </span><span>x&#39;</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>x1f</span><span> </span><span>x2f</span><span>
</span><span>       </span><span>x1g</span><span> </span><span>x1h</span><span> </span><span>x2g</span><span> </span><span>x2h</span><span> </span><span>aa</span><span> </span><span>ab</span><span> </span><span>ac</span><span> </span><span>ad</span><span> </span><span>ba</span><span> </span><span>baa</span><span> </span><span>ca</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x2e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>6</span><span> </span><span>6</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_def</span><span> </span><span>Image_iff</span><span> </span><span>converse_iff</span><span> </span><span>prod_rel_iff</span><span>
</span><span>         </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x2e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trail_pol_no_CS_last_hd</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((x1h, t), M) &#8712; trail_pol_no_CS &#119964; &#10233; M &#8800; [] &#10233; (last x1h) = lit_of (hd M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1h</span><span> </span><span>t</span><span> </span><span>M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>last_map</span><span> </span><span>last_rev</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trail_conv_back</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_conv_back_imp x2b x1g
        &#8804; SPEC
           (&#955;c. (c, trail_conv_back x2 x1e)
                &#8712; trail_pol &#119964;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case y of (x, xa) &#8658; (case x of (M, lev) &#8658; &#955;vm. lev &lt; count_decided M) xa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 = (x1a, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y = (x1, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1b = (x1c, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1b, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_length_trail_pre (trail_pol_conv_to_no_CS x1c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(pos, posa) &#8712; nat_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail_conv_to_no_CS x1a) - posa &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_length_trail (trail_pol_conv_to_no_CS x1c) - pos &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(xa, x&#39;) &#8712; nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> (trail_pol_no_CS &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> (Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> distinct_atoms_rel &#119964;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2d = (x1e, x2e)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#39; = (x1d, x2d)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2f = (x1g, x2g)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa = (x1f, x2f)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = count_decided x1e&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x1c</span><span> </span><span>x2b</span><span> </span><span>x2c</span><span> </span><span>pos</span><span> </span><span>posa</span><span> </span><span>xa</span><span> </span><span>x&#39;</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>x1f</span><span> </span><span>x2f</span><span>
</span><span>       </span><span>x1g</span><span> </span><span>x2g</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trail_conv_back</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_curry</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conc_fun_RETURN</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>trail_pol_conv_to_no_CS_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>trail_conv_to_no_CS_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_find_decomp_wl_imp_def</span><span> </span><span>find_decomp_wl_imp_def</span><span> </span><span>uncurry_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>      </span><span>id_trail_conv_to_no_CS</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span>get_pos_of_level_in_trail_imp_get_pos_of_level_in_trail</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_curry</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isa_length_trail_pre</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_pos_of_level_in_trail_pre_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>isa_length_trail_length_u_no_CS</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_Id</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>isa_length_trail_length_u_no_CS</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_Id</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>10</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>isa_length_trail_length_u_no_CS</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_Id</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>isa_length_trail_length_u_no_CS</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_Id</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>trail_pol_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>trail_pol_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x1c</span><span> </span><span>x2b</span><span> </span><span>x2c</span><span> </span><span>pos</span><span> </span><span>posa</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tl_trailt_tr_no_CS_pre</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x1</span><span> </span><span>x1a</span><span> </span><span>x2</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x1c</span><span> </span><span>x2b</span><span> </span><span>x2c</span><span> </span><span>pos</span><span> </span><span>posa</span><span> </span><span>xa</span><span> </span><span>x&#39;</span><span> </span><span>x1d</span><span> </span><span>x2d</span><span> </span><span>x1e</span><span> </span><span>x2e</span><span> </span><span>x1f</span><span> </span><span>x2f</span><span>
</span><span>       </span><span>x1g</span><span> </span><span>x1h</span><span> </span><span>x2g</span><span> </span><span>x2h</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x1g</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>x2h</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vmtf_unset_pre</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>&#119964;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop x1d x1a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>isa_vmtf</span><span>
</span><span>           </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lit_of_last_trail_pol_def</span><span> </span><span>trail_pol_no_CS_last_hd</span><span> </span><span>lit_of_hd_trail_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lit_of_last_trail_pol_def</span><span> </span><span>trail_pol_no_CS_last_hd</span><span> </span><span>lit_of_hd_trail_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tl_trail_tr_no_CS</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET</span><span class="delimiter">]</span><span>
</span><span>          </span><span>isa_vmtf_unset_vmtf_unset</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_unRET_uncurry</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trail_conv_back</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>find_decomp_wl_st</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal &#8658; nat twl_st_wl &#8658; nat twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_wl_st = (&#955;L (M, N, D, oth).  do{
     M&#39; &#8592; find_decomp_wl&#39; M (the D) L;
    RETURN (M&#39;, N, D, oth)
  })&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_decomp_wl_st_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; twl_st_wl_heur &#8658; twl_st_wl_heur nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_wl_st_int = (&#955;highest (M, N, D, Q, W, vm, &#966;, clvls, cach, lbd, stats). do{
     (M&#39;, vm) &#8592; isa_find_decomp_wl_imp M highest vm;
     RETURN (M&#39;, N, D, Q, W, vm, &#966;, clvls, cach, lbd, stats)
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>vm</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; vmtf &#119964; M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lits</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail &#119964; M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>target</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;highest &lt; count_decided M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>find_decomp_wl_imp_le_find_decomp_wl&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_wl_imp &#119964; M<span class="hidden">&#8681;</span><sub>0</sub> highest vm &#8804; find_decomp_w_ns &#119964; M<span class="hidden">&#8681;</span><sub>0</sub> highest vm&#8250;</span></span></span><span>
</span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?decomp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length_M0</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M<span class="hidden">&#8681;</span><sub>0</sub> &#8804; uint32_max div 2 + 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_trail_uint32_max_div2</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span> </span><span>M<span class="hidden">&#8681;</span><sub>0</sub></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>bounded</span><span class="delimiter">]</span><span>
</span><span>      </span><span>n_d</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail_in_lits_of_l</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>lits</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((count_decided x1g, x1g), count_decided x1, x1) &#8712; Id&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1g = x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1g</span><span> </span><span>x1</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, nat) ann_lits&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;M&#39;a. M&#39; @ x2g = M&#39;a @ tl x2g&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M&#39;</span><span> </span><span>x2g</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, nat) ann_lits&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; @ (if x2g = [] then [] else [hd x2g])&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>butlast_nil_iff</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;butlast xs = [] &#10231; xs = [] &#8744; (&#8707;a. xs = [a])&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, nat) ann_lits&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>butlast1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl x2g = drop (Suc (length x1) - length x2g) x1&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?G1&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2g = drop (length x1 - length x2g) x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x2g</span><span> </span><span>x1</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a list&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (length x1 - length x2g) = Suc (length x1) - length x2g&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_le</span><span> </span><span>diff_le_mono2</span><span> </span><span>diff_zero</span><span> </span><span>length_drop</span><span> </span><span>that</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?G1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>that</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>butlast_conv_take</span><span> </span><span>tl_drop_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>butlast2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl x2g = drop (length x1 - (length x2g - Suc 0)) x1&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?G2&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2g = drop (length x1 - length x2g) x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x2g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2g &#8800; []&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x2g</span><span> </span><span>x1</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a list&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (length x1 - length x2g) = Suc (length x1) - length x2g&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_le</span><span> </span><span>diff_le_mono2</span><span> </span><span>diff_zero</span><span> </span><span>length_drop</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (length x1) - length x2g = length x1 - (length x2g - Suc 0)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x2g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?G2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>that</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>butlast_conv_take</span><span> </span><span>tl_drop_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>butlast</span><span> </span><span class="delimiter">=</span><span> </span><span>butlast1</span><span> </span><span>butlast2</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_decided_not_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; count_decided M &#10233; M &#8800; []&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, nat) ann_lits&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>get_lev_last</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (M&#39; @ M) (lit_of (last M&#39;)) = Suc (count_decided M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M<span class="hidden">&#8681;</span><sub>0</sub> = M&#39; @ M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; &#8800; []&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_decided (last M&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M&#39;</span><span> </span><span>M</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atm_of_N</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (lit_of `# mset aa) &#10233; aa &#8800; [] &#10233; atm_of (lit_of (hd aa)) &#8712; atms_of (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>aa</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>aa</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_add_mset</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Lin_drop_tl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (lit_of `# mset (drop b M<span class="hidden">&#8681;</span><sub>0</sub>)) &#10233;
      literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (lit_of `# mset (tl (drop b M<span class="hidden">&#8681;</span><sub>0</sub>)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_mono</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop b M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>highest</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;highest = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>ex_decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;K M2.
       (Decided K # M, M2)
       &#8712; set (get_all_ann_decomposition M<span class="hidden">&#8681;</span><sub>0</sub>) &#8743;
       get_level M<span class="hidden">&#8681;</span><sub>0</sub> K = Suc highest &#8743; vm &#8712; vmtf &#119964; M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>pos</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;pos &lt; length M<span class="hidden">&#8681;</span><sub>0</sub> &#8743; is_decided (rev M<span class="hidden">&#8681;</span><sub>0</sub> ! pos) &#8743; get_level M<span class="hidden">&#8681;</span><sub>0</sub> (lit_of (rev M<span class="hidden">&#8681;</span><sub>0</sub> ! pos)) =
         highest + 1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M<span class="hidden">&#8681;</span><sub>0</sub> - pos &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case s of (j, M, vm&#39;) &#8658;
         j &#8804; length M<span class="hidden">&#8681;</span><sub>0</sub> - pos &#8743;
         M = drop j M<span class="hidden">&#8681;</span><sub>0</sub> &#8743;
         length M<span class="hidden">&#8681;</span><sub>0</sub> - pos &#8804; length M<span class="hidden">&#8681;</span><sub>0</sub> &#8743;
         vm&#39; &#8712; vmtf &#119964; M &#8743;
         literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (lit_of `# mset M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>cond</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; (case s of
         (j, M, vm) &#8658; j &lt; length M<span class="hidden">&#8681;</span><sub>0</sub> - pos)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>s</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;s = (j, s&#39;)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;s&#39; = (M, vm)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pos</span><span> </span><span>s</span><span> </span><span>j</span><span> </span><span>s&#39;</span><span> </span><span>M</span><span> </span><span>vm</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j = length M<span class="hidden">&#8681;</span><sub>0</sub> - pos&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = drop (length M<span class="hidden">&#8681;</span><sub>0</sub> - pos) M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>vm</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vm &#8712; vmtf &#119964; (drop (length M<span class="hidden">&#8681;</span><sub>0</sub> - pos) M<span class="hidden">&#8681;</span><sub>0</sub>)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#119964; (lit_of `# mset (drop (length M<span class="hidden">&#8681;</span><sub>0</sub> - pos) M<span class="hidden">&#8681;</span><sub>0</sub>))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cond</span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2 = take (length M<span class="hidden">&#8681;</span><sub>0</sub> - Suc pos) M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = rev M<span class="hidden">&#8681;</span><sub>0</sub> ! pos&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le_Suc_pos</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M<span class="hidden">&#8681;</span><sub>0</sub> - pos = Suc (length M<span class="hidden">&#8681;</span><sub>0</sub> - Suc pos)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;take (length M<span class="hidden">&#8681;</span><sub>0</sub> - pos) M<span class="hidden">&#8681;</span><sub>0</sub> = take (length M<span class="hidden">&#8681;</span><sub>0</sub> - Suc pos) M<span class="hidden">&#8681;</span><sub>0</sub> @ [rev M<span class="hidden">&#8681;</span><sub>0</sub> ! pos]&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>le_Suc_pos</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rev_nth</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M<span class="hidden">&#8681;</span><sub>0</sub></span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M<span class="hidden">&#8681;</span><sub>0</sub> = M2 @ L # M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>append_take_drop_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M<span class="hidden">&#8681;</span><sub>0</sub> - pos&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>L_def</span><span> </span><span>M2_def</span><span> </span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided (lit_of L) = L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M<span class="hidden">&#8681;</span><sub>0</sub>&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M<span class="hidden">&#8681;</span><sub>0</sub> = M2 @ Decided (lit_of L) # M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;highest = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M<span class="hidden">&#8681;</span><sub>0</sub> (lit_of L) = Suc highest&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_decided L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>pos</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M<span class="hidden">&#8681;</span><sub>0</sub></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;K M2.
       (Decided K # M, M2)
       &#8712; set (get_all_ann_decomposition M<span class="hidden">&#8681;</span><sub>0</sub>) &#8743;
       get_level M<span class="hidden">&#8681;</span><sub>0</sub> K = Suc highest &#8743; vm &#8712; vmtf &#119964; M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_all_ann_decomposition_ex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of L&#8250;</span></span></span><span> </span><span>M</span><span> </span><span>M2</span><span class="delimiter">]</span><span> </span><span>vm</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M<span class="hidden">&#8681;</span><sub>0</sub>&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>M</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;highest = count_decided M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;highest = count_decided M&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?decomp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_decomp_wl_imp_def</span><span> </span><span>Let_def</span><span> </span><span>find_decomp_w_ns_def</span><span> </span><span>trail_conv_to_no_CS_def</span><span>
</span><span>      </span><span>get_pos_of_level_in_trail_def</span><span> </span><span>trail_conv_back_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>1</span><span> </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;measure (&#955;(_, M, _). length M)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_M0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint32_max_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>target</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_decided_ge_get_maximum_level</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lits</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail_lit_of_mset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>target</span><span> </span><span>s</span><span> </span><span>j</span><span> </span><span>b</span><span> </span><span>M</span><span> </span><span>vm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_M0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint32_max_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>s</span><span> </span><span>a</span><span> </span><span>ab</span><span> </span><span>aa</span><span> </span><span>bb</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop a M<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lit_of_hd_trail_def</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>drop_Suc</span><span> </span><span>drop_tl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>aa</span><span> </span><span>ba</span><span> </span><span>vm</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vm</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vmtf_unset_vmtf_tl</span><span> </span><span>atm_of_N</span><span> </span><span>drop_tl</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lit_of_hd_trail_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>aa</span><span> </span><span>ba</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lits</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Lin_drop_tl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>highest</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ex_decomp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>find_decomp_wl_imp_find_decomp_wl&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 (find_decomp_wl_imp &#119964;), uncurry2 (find_decomp_w_ns &#119964;)) &#8712;
    [find_decomp_w_ns_pre &#119964;]<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#8594; &#10216;Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>find_decomp_w_ns_pre_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>twl_st_of_wl.simps</span><span>
</span><span>       </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>find_decomp_wl_imp_le_find_decomp_wl&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>find_decomp_wl_imp_code_conbine_cond</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;((b, a), c). find_decomp_w_ns_pre &#119964; ((b, a), c) &#8743; a &lt; count_decided b) = (&#955;((b, a), c).
         find_decomp_w_ns_pre &#119964; ((b, a), c))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>find_decomp_w_ns_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">1775f91f0787 </td><td align="center">271ed48b </td><td align="center">Mo 20 Jn 2020 16:45:39 CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


