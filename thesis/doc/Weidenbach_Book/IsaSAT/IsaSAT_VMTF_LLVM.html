<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IsaSAT_VMTF_LLVM (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IsaSAT_VMTF_LLVM</h1>

<span class="command">theory</span> <span class="name">IsaSAT_VMTF_LLVM</span><br/>
<span class="keyword">imports</span> <a href="IsaSAT_VMTF.html"><span class="name">IsaSAT_VMTF</span></a> <a href="IsaSAT_Sorting_LLVM.html"><span class="name">IsaSAT_Sorting_LLVM</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IsaSAT_VMTF_LLVM</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Watched_Literals.WB_Sort</span><span> </span><span>IsaSAT_VMTF</span><span> </span><span>IsaSAT_Setup_LLVM</span><span>
</span><span>   </span><span>Isabelle_LLVM.Sorting_Introsort</span><span>
</span><span>   </span><span>IsaSAT_Sorting_LLVM</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Mathias! Only import the refinement stuff over a single point,
  and at this point, do all necessary adaptations.

  Currently, this point is Refine_Monadic_Thin

*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*declare is_None_def[simp del] *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma VMTF_Node_ref[sepref_fr_rules]:
  &#8249;(uncurry2 (return ooo VMTF_Node), uncurry2 (RETURN ooo VMTF_Node)) &#8712;
    uint64_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (option_assn uint32_nat_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (option_assn uint32_nat_assn)<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
    vmtf_node_assn&#8250;
  by sepref_to_hoare
   (sep_auto simp: vmtf_node_rel_def uint32_nat_rel_def br_def option_assn_alt_def
     split: option.splits)

lemma stamp_ref[sepref_fr_rules]:
  &#8249;(return o stamp, RETURN o stamp) &#8712; vmtf_node_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> uint64_nat_assn&#8250;
  by sepref_to_hoare
    (auto simp: ex_assn_move_out(2)[symmetric] return_cons_rule ent_ex_up_swap vmtf_node_rel_def
      simp del: ex_assn_move_out)

lemma get_next_ref[sepref_fr_rules]:
  &#8249;(return o get_next, RETURN o get_next) &#8712; vmtf_node_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
   option_assn uint32_nat_assn&#8250;
  unfolding option_assn_pure_conv
  by sepref_to_hoare (sep_auto simp: return_cons_rule vmtf_node_rel_def)

lemma get_prev_ref[sepref_fr_rules]:
  &#8249;(return o get_prev, RETURN o get_prev) &#8712; vmtf_node_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
   option_assn uint32_nat_assn&#8250;
  unfolding option_assn_pure_conv
  by sepref_to_hoare (sep_auto simp: return_cons_rule vmtf_node_rel_def)
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_atoms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_vmtf_node list &#8658; nat set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;valid_atoms xs &#8801; {i. i &lt; length xs}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VMTF_score_less</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;VMTF_score_less xs i j &#10231; stamp (xs ! i) &lt; stamp (xs ! j)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mop_VMTF_score_less</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mop_VMTF_score_less xs i j = do {
    ASSERT(i &lt; length xs);
    ASSERT(j &lt; length xs);
    RETURN (stamp (xs ! i) &lt; stamp (xs ! j))
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>VMTF_score_less</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>mop_VMTF_score_less_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry2 (mop_VMTF_score_less)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(array_assn vmtf_node_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> atom_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_VMTF_score_less_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;stamp (_ ! &#8977;)&#8250;</span></span></span><span> </span><span>value_of_atm_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;stamp (_ ! &#8977;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &lt; &#8977;&#8250;</span></span></span><span> </span><span>value_of_atm_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>index_of_atm_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>VMTF</span><span class="delimiter">:</span><span> </span><span>weak_ordering_on_lt</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;valid_atoms vs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>less</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VMTF_score_less vs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VMTF_score_less_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>VMTF</span><span class="delimiter">:</span><span> </span><span>parameterized_weak_ordering</span><span> </span><span>valid_atoms</span><span> </span><span>VMTF_score_less</span><span>
</span><span>    </span><span>mop_VMTF_score_less</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mop_VMTF_score_less_def</span><span>
</span><span>     </span><span>valid_atoms_def</span><span> </span><span>VMTF_score_less_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">global_interpretation</span></span><span> </span><span>VMTF</span><span class="delimiter">:</span><span> </span><span>parameterized_sort_impl_context</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;woarray_assn atom_assn&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eoarray_assn atom_assn&quot;</span></span></span><span> </span><span>atom_assn</span><span>
</span><span>  </span><span>return</span><span> </span><span>return</span><span>
</span><span>  </span><span>eo_extract_impl</span><span>
</span><span>  </span><span>array_upd</span><span>
</span><span>  </span><span>valid_atoms</span><span> </span><span>VMTF_score_less</span><span> </span><span>mop_VMTF_score_less</span><span> </span><span>mop_VMTF_score_less_impl</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;array_assn vmtf_node_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>          </span><span>VMTF_is_guarded_insert_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.is_guarded_param_insert_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_is_unguarded_insert_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.is_unguarded_param_insert_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_unguarded_insertion_sort_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.unguarded_insertion_sort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_guarded_insertion_sort_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.guarded_insertion_sort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_final_insertion_sort_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.final_insertion_sort_param_impl</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*and VMTF_mop_lchild_impl  = VMTF.mop_lchild_impl
      and VMTF_mop_rchild_impl  = VMTF.mop_rchild_impl
      and VMTF_has_rchild_impl  = VMTF.has_rchild_impl
      and VMTF_has_lchild_impl  = VMTF.has_lchild_impl *)</span></span></span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_pcmpo_idxs_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF.pcmpo_idxs_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_pcmpo_v_idx_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF.pcmpo_v_idx_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_pcmpo_idx_v_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF.pcmpo_idx_v_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_pcmp_idxs_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF.pcmp_idxs_impl</span><span>
</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_mop_geth_impl</span><span>    </span><span class="delimiter">=</span><span> </span><span>VMTF.mop_geth_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_mop_seth_impl</span><span>    </span><span class="delimiter">=</span><span> </span><span>VMTF.mop_seth_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_sift_down_impl</span><span>   </span><span class="delimiter">=</span><span> </span><span>VMTF.sift_down_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_heapify_btu_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.heapify_btu_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_heapsort_impl</span><span>    </span><span class="delimiter">=</span><span> </span><span>VMTF.heapsort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_qsp_next_l_impl</span><span>       </span><span class="delimiter">=</span><span> </span><span>VMTF.qsp_next_l_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_qsp_next_h_impl</span><span>       </span><span class="delimiter">=</span><span> </span><span>VMTF.qsp_next_h_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_qs_partition_impl</span><span>     </span><span class="delimiter">=</span><span> </span><span>VMTF.qs_partition_impl</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*      and VMTF_qs_partitionXXX_impl     = VMTF.qs_partitionXXX_impl *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_partition_pivot_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF.partition_pivot_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_introsort_aux_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.introsort_aux_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_introsort_impl</span><span>        </span><span class="delimiter">=</span><span> </span><span>VMTF.introsort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_move_median_to_first_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF.move_median_to_first_param_impl</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eo_hnr_dep</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>GEN_ALGO_def</span><span> </span><span>refines_param_relp_def</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: thm gen_refines_param_relpI *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span class="delimiter">[</span><span class="delimiter">[</span><span>unify_trace_failure</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mop_VMTF_score_less_impl.refine</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">global_interpretation</span></span><span>
</span><span>  </span><span>VMTF_it</span><span class="delimiter">:</span><span> </span><span>pure_eo_adapter</span><span> </span><span>atom_assn</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;arl64_assn atom_assn&quot;</span></span></span><span> </span><span>arl_nth</span><span> </span><span>arl_upd</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>VMTF_it_eo_extract_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.eo_extract_impl</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>al_pure_eo</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_constraint_rules</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">global_interpretation</span></span><span> </span><span>VMTF_it</span><span class="delimiter">:</span><span> </span><span>parameterized_sort_impl_context</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>wo_assn</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arl64_assn atom_assn&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eo_assn</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.eo_assn</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>elem_assn</span><span> </span><span class="delimiter">=</span><span> </span><span>atom_assn</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>to_eo_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>return</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>to_wo_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>return</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>extract_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it_eo_extract_impl</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>arl_upd</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cdom</span><span> </span><span class="delimiter">=</span><span> </span><span>valid_atoms</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pless</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_score_less</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pcmp</span><span> </span><span class="delimiter">=</span><span> </span><span>mop_VMTF_score_less</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pcmp_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>mop_VMTF_score_less_impl</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cparam_assn</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;array_assn vmtf_node_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>          </span><span>VMTF_it_is_guarded_insert_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.is_guarded_param_insert_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_is_unguarded_insert_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.is_unguarded_param_insert_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_unguarded_insertion_sort_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.unguarded_insertion_sort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_guarded_insertion_sort_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.guarded_insertion_sort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_final_insertion_sort_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.final_insertion_sort_param_impl</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*and VMTF_it_mop_lchild_impl  = VMTF_it.mop_lchild_impl
      and VMTF_it_mop_rchild_impl  = VMTF_it.mop_rchild_impl
      and VMTF_it_has_rchild_impl  = VMTF_it.has_rchild_impl
      and VMTF_it_has_lchild_impl  = VMTF_it.has_lchild_impl *)</span></span></span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_pcmpo_idxs_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF_it.pcmpo_idxs_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_pcmpo_v_idx_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF_it.pcmpo_v_idx_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_pcmpo_idx_v_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF_it.pcmpo_idx_v_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_pcmp_idxs_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF_it.pcmp_idxs_impl</span><span>
</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_mop_geth_impl</span><span>    </span><span class="delimiter">=</span><span> </span><span>VMTF_it.mop_geth_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_mop_seth_impl</span><span>    </span><span class="delimiter">=</span><span> </span><span>VMTF_it.mop_seth_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_sift_down_impl</span><span>   </span><span class="delimiter">=</span><span> </span><span>VMTF_it.sift_down_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_heapify_btu_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.heapify_btu_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_heapsort_impl</span><span>    </span><span class="delimiter">=</span><span> </span><span>VMTF_it.heapsort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_qsp_next_l_impl</span><span>       </span><span class="delimiter">=</span><span> </span><span>VMTF_it.qsp_next_l_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_qsp_next_h_impl</span><span>       </span><span class="delimiter">=</span><span> </span><span>VMTF_it.qsp_next_h_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_qs_partition_impl</span><span>     </span><span class="delimiter">=</span><span> </span><span>VMTF_it.qs_partition_impl</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*      and VMTF_it_qs_partitionXXX_impl     = VMTF_it.qs_partitionXXX_impl *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_partition_pivot_impl</span><span>  </span><span class="delimiter">=</span><span> </span><span>VMTF_it.partition_pivot_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_introsort_aux_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.introsort_aux_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_introsort_impl</span><span>        </span><span class="delimiter">=</span><span> </span><span>VMTF_it.introsort_param_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VMTF_it_move_median_to_first_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.move_median_to_first_param_impl</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>GEN_ALGO_def</span><span> </span><span>refines_param_relp_def</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: thm gen_refines_param_relpI *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mop_VMTF_score_less_impl.refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>VMTF_it.eo_extract_impl_def</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>meta_fun_cong</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>meta_fun_cong</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">print_named_simpset</span></span><span> </span><span>llvm_inline</span><span>
</span><span class="keyword1"><span class="command">export_llvm</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;VMTF_heapsort_impl :: _ &#8658; _ &#8658; _&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;VMTF_introsort_impl :: _ &#8658; _ &#8658; _&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VMTF_sort_scores_raw</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;VMTF_sort_scores_raw = pslice_sort_spec valid_atoms VMTF_score_less&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VMTF_sort_scores</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;VMTF_sort_scores xs ys = VMTF_sort_scores_raw xs ys 0 (length ys)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>VMTF_introsort</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>VMTF_it.introsort_param_impl_correct</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>VMTF_sort_scores_raw_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>PR_CONST_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>VMTF_sort_scores_raw</span><span> </span><span>vmtf_reorder_list_raw</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VMTF_sort_scores_vmtf_reorder_list_raw</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(VMTF_sort_scores, vmtf_reorder_list_raw) &#8712; Id &#8594; Id &#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VMTF_sort_scores_def</span><span> </span><span>VMTF_sort_scores_raw_def</span><span> </span><span>pslice_sort_spec_def</span><span>
</span><span>    </span><span>vmtf_reorder_list_raw_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_atoms_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>vm</span><span> </span><span>vm&#39;</span><span> </span><span>arr</span><span> </span><span>arr&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>slice_sort_spec_refine_sort</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>arr&#39;</span><span> </span><span>arr&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_atoms_def</span><span> </span><span>slice_rel_def</span><span> </span><span>br_def</span><span> </span><span>reorder_list_def</span><span> </span><span>conc_fun_RES</span><span> </span><span>sort_spec_def</span><span>
</span><span>      </span><span>eq_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length arr&#39;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>VMTF_sort_scores_raw_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry VMTF_sort_scores&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(IICF_Array.array_assn vmtf_node_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> VMTF_it.arr_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> VMTF_it.arr_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VMTF_sort_scores_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>VMTF_sort_scores_raw_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>VMTF_sort_scores_vmtf_reorder_list_raw</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>VMTF_sort_scores_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry vmtf_reorder_list&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(vmtf_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> VMTF_it.arr_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> VMTF_it.arr_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_reorder_list_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>atoms_hash_del_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo atoms_hash_del)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[uncurry atoms_hash_del_pre]<span class="hidden">&#8681;</span><sub>a</sub> atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (atoms_hash_assn)<span class="hidden">&#8679;</span><sup>d</sup> &#8594; atoms_hash_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atoms_hash_del_def</span><span> </span><span>atoms_hash_del_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>annot_all_atm_idxs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>atoms_hash_insert_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo atoms_hash_insert)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[uncurry atms_hash_insert_pre]<span class="hidden">&#8681;</span><sub>a</sub>
      atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (distinct_atoms_assn)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;  distinct_atoms_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atoms_hash_insert_def</span><span> </span><span>atms_hash_insert_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>annot_all_atm_idxs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>find_decomp_wl_imp</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>rescore_clause</span><span> </span><span>vmtf_flush</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>vmtf_mark_to_rescore</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>vmtf_mark_to_rescore_clause</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>vmtf_mark_to_rescore_also_reasons</span><span> </span><span>get_the_propagation_reason_pol</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>find_decomp_w_ns</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>update_next_search_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo update_next_search)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(atom.option_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update_next_search_def</span><span> </span><span>vmtf_remove_assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>case_option_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(case a of None &#8658; x | Some y &#8658; f y) =
   (if is_None a then x else let y = the a in f y)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma is_pure_snat_option[safe_constraint_rules]: &#8249;CONSTRAINT is_pure snat.option_assn&#8250;
  using snat.A_pure snat.option_assn_pure unfolding CONSTRAINT_def by blast
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>ns_vmtf_dequeue_code</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo ns_vmtf_dequeue)&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[vmtf_dequeue_pre]<span class="hidden">&#8681;</span><sub>a</sub>
        atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (array_assn vmtf_node_assn)<span class="hidden">&#8679;</span><sup>d</sup> &#8594; array_assn vmtf_node_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span> </span><span>if_splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ns_vmtf_dequeue_def</span><span> </span><span>vmtf_dequeue_pre_alt_def</span><span> </span><span>case_option_split</span><span> </span><span>atom.fold_option</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>annot_all_atm_idxs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>get_next</span><span> </span><span>get_prev</span><span> </span><span>stamp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_Some_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = Some b &#10231; (&#172;is_None x &#8743; the x = b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_refine_with_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P x &#10233; g&#39; x &#8804; g x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g&#39;) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> A &#8594; R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> A &#8594; R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>hfrefD</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>hfrefI</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>hn_refine_ref</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_en_dequeue_preI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isa_vmtf_en_dequeue_pre ((M,L),(ns, m, fst_As, lst_As, next_search))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst_As &lt; length ns&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L &lt; length ns&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc m &lt; max_unat 64&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_next (ns!L) = Some i &#10230; i &lt; length ns&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst_As &#8800; lst_As &#10230; get_prev (ns ! lst_As) &#8800; None&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_next (ns ! fst_As) &#8800; None &#10230; get_prev (ns ! lst_As) &#8800; None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_en_dequeue_pre_def</span><span> </span><span>vmtf_dequeue_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_unat_def</span><span> </span><span>uint64_max_def</span><span> </span><span>sint64_max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8800; None &#10231; _&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_en_dequeue_alt_def2</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue_pre x &#10233; uncurry2 (&#955;M L vm.
    case vm of (ns, m, fst_As, lst_As, next_search) &#8658; doN {
      ASSERT(L&lt;length ns);
      nsL &#8592; mop_list_get ns (index_of_atm L);
      let fst_As = (if fst_As = L then get_next nsL else (Some fst_As));

      let next_search = (if next_search = (Some L) then get_next nsL
                        else next_search);
      let lst_As = (if lst_As = L then get_prev nsL else (Some lst_As));
      ASSERT (vmtf_dequeue_pre (L,ns));
      let ns = ns_vmtf_dequeue L ns;
      ASSERT (defined_atm_pol_pre M L);
      let de = (defined_atm_pol M L);
      ASSERT (Suc m &lt; max_unat 64);
      case fst_As of
        None &#8658; RETURN
          (ns[L := VMTF_Node m fst_As None], m + 1, L, L,
           if de then None else Some L)
      | Some fst_As &#8658; doN {
          ASSERT (L &lt; length ns &#8743; fst_As &lt; length ns &#8743; lst_As &#8800; None);
          let fst_As&#39; =
                VMTF_Node (stamp (ns ! fst_As)) (Some L)
                 (get_next (ns ! fst_As));
          RETURN (
            ns[L := VMTF_Node (m + 1) None (Some fst_As),
            fst_As := fst_As&#39;],
            m + 1, L, the lst_As,
            if de then next_search else Some L)
      }
    }) x
  &#8804; uncurry2 (isa_vmtf_en_dequeue) x
    &#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_en_dequeue_def</span><span> </span><span>vmtf_dequeue_def</span><span> </span><span>isa_vmtf_enqueue_def</span><span>
</span><span>    </span><span>annot_unat_snat_upcast</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ASSN_ANNOT_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span>
</span><span>    </span><span>only</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span>
</span><span>    </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>isa_vmtf_en_dequeue_preD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*isa_vmtf_en_dequeue_pre_vmtf_enqueue_pre[dest]*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>    </span><span>split</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>option.splits</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span> </span><span>isa_vmtf_en_dequeue_preI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_en_dequeue_preI</span><span>
</span><span>    </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>not_None_eq</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*dest: isa_vmtf_en_dequeue_preI*)</span></span></span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This is a general setup to identify any numeral by id-op (numeral is already in Sepref_Id_Op.thy.)
  Note: Naked int/nat numerals will be rejected by translate, as they need to be type-annotated.
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>1</span><span> </span><span>0</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vmtf_en_dequeue_fast_codeI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isa_vmtf_en_dequeue_pre ((M, L),(ns,m,fst_As, lst_As, next_search))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc m &lt; max_unat 64&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_en_dequeue_pre_def</span><span> </span><span>max_unat_def</span><span> </span><span>uint64_max_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>mk_free_trail_pol_fast_assn</span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE trail_pol_fast_assn ?fr&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_fast_assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_thms</span><span> </span><span>sepref_frame_free_rules</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Write a method for that! *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>vmtf_en_dequeue_fast_code</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry2 isa_vmtf_en_dequeue&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[isa_vmtf_en_dequeue_pre]<span class="hidden">&#8681;</span><sub>a</sub>
        trail_pol_fast_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; vmtf_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_refine_with_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>isa_vmtf_en_dequeue_alt_def2</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_en_dequeue_alt_def2</span><span> </span><span>case_option_split</span><span> </span><span>eq_Some_iff</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;if &#8977; then get_next _ else _&quot;</span></span></span><span> </span><span>short_circuit_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>annot_all_atm_idxs</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atom.fold_option</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fold_tuple_optimizations</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>vmtf_rescale</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>vmtf_rescale_code</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_rescale&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> vmtf_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>vmtf_en_dequeue_pre_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_rescale_alt_def</span><span> </span><span>update_stamp.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atom.fold_option</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>annot_all_atm_idxs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>partition_between_ref</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma partition_between_ref_vmtf_code_aux:
  &quot;&#10214;(loi,lo)&#8712;snat_rel&#39; TYPE(64); (hii,hi)&#8712;snat_rel&#39; TYPE(64)&#10215; &#10233; lo + (hi - lo) div 2 &lt; max_snat 64&quot;
  apply sepref_bounds
  apply (drule in_snat_rel_imp_less_max&#39;)+
  by auto
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>isa_vmtf_enqueue</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma uint64_nal_rel_le_uint64_max: &#8249;(a, b) &#8712; uint64_nat_rel &#10233; b &#8804; uint64_max&#8250;
  by (auto simp: uint64_nat_rel_def br_def nat_of_uint64_le_uint64_max)
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emptied_list_alt_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;emptied_list xs = take 0 xs&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emptied_list_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>current_stamp_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o current_stamp&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;vmtf_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> uint64_nat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>current_stamp_alt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>isa_vmtf_en_dequeue</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>isa_vmtf_flush_fast_code</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry isa_vmtf_flush_int&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol_fast_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (vmtf_remove_assn)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
        vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vmtf_flush_def</span><span> </span><span>PR_CONST_def</span><span> </span><span>isa_vmtf_flush_int_def</span><span>
</span><span>    </span><span>current_stamp_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>emptied_list_alt_def</span><span>
</span><span>    </span><span>vmtf_remove_assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If (_ - _ &#8804; &#8977;) _ _&#8250;</span></span></span><span> </span><span>annot_snat_unat_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;WHILEIT _ (&#955;(_, _, _)._ &lt; &#8977;)&#8250;</span></span></span><span> </span><span>annot_snat_unat_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_vmtf_en_dequeue _ (_ ! &#8977;)&#8250;</span></span></span><span> </span><span>annot_unat_snat_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atoms_hash_del (_ ! &#8977;)&#8250;</span></span></span><span> </span><span>annot_unat_snat_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;take &#8977; _&#8250;</span></span></span><span> </span><span>snat_const_fold</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span>64</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>isa_vmtf_mark_to_rescore</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>isa_vmtf_mark_to_rescore_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo isa_vmtf_mark_to_rescore)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[uncurry isa_vmtf_mark_to_rescore_pre]<span class="hidden">&#8681;</span><sub>a</sub>
     atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span> </span><span>vmtf_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>    </span><span>neq_NilE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_add_mset</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_pre_def</span><span> </span><span>isa_vmtf_mark_to_rescore_def</span><span> </span><span>vmtf_remove_assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>isa_vmtf_unset</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>isa_vmtf_unset_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo isa_vmtf_unset)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[uncurry vmtf_unset_pre]<span class="hidden">&#8681;</span><sub>a</sub>
     atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span> </span><span>vmtf_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>    </span><span>neq_NilE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_add_mset</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_unset_def</span><span> </span><span>vmtf_unset_pre_def</span><span> </span><span>vmtf_remove_assn_def</span><span> </span><span>atom.fold_option</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If (_ &#8744; _)&#8250;</span></span></span><span> </span><span>short_circuit_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>annot_all_atm_idxs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_vmtf_mark_to_rescore_and_unsetI</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
     atms_hash_insert_pre ak (ad, ba) &#10233;
       isa_vmtf_mark_to_rescore_pre ak ((a, aa, ab, ac, Some ak&#39;), ad, ba)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_vmtf_mark_to_rescore_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>vmtf_mark_to_rescore_and_unset_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo isa_vmtf_mark_to_rescore_and_unset)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[isa_vmtf_mark_to_rescore_and_unset_pre]<span class="hidden">&#8681;</span><sub>a</sub>
      atom_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>image_image</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span> </span><span>in_diffD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>    </span><span>if_splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span> </span><span>isa_vmtf_unset_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>isa_vmtf_mark_to_rescore_and_unsetI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_and_unset_def</span><span> </span><span>isa_vmtf_mark_to_rescore_and_unset_pre_def</span><span>
</span><span>    </span><span>save_phase_def</span><span> </span><span>isa_vmtf_mark_to_rescore_and_unset_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>find_decomp_wl_imp_fast_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry2 (isa_find_decomp_wl_imp)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[&#955;((M, lev), vm). True]<span class="hidden">&#8681;</span><sub>a</sub> trail_pol_fast_assn<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup>
    &#8594; trail_pol_fast_assn &#215;<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_find_decomp_wl_imp_def</span><span> </span><span>get_maximum_level_remove_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>PR_CONST_def</span><span>
</span><span>    </span><span>trail_pol_conv_to_no_CS_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>trail_conv_to_no_CS_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>lit_of_hd_trail_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_add_mset</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>vmtf_unset_pre_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;let _ = _ - &#8977; in _&#8250;</span></span></span><span> </span><span>annot_unat_snat_upcast</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;l</span><span class="delimiter">=</span><span>64</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>vmtf_rescore_fast_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry2 isa_vmtf_rescore&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause_ll_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> trail_pol_fast_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
       vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_rescore_body_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>PR_CONST_def</span><span> </span><span>isa_vmtf_rescore_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>fold_is_None</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>find_decomp_wl_imp&#39;_fast_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry find_decomp_wl_st_int&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> isasat_bounded_assn<span class="hidden">&#8679;</span><sup>d</sup>  &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
        isasat_bounded_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_decomp_wl_st_int_def</span><span> </span><span>PR_CONST_def</span><span> </span><span>isasat_bounded_assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fold_tuple_optimizations</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>arena_is_valid_clause_idx_le_uint64_max</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arena_is_valid_clause_idx be bd &#10233;
    length be &#8804; sint64_max &#10233;
   bd + arena_length be bd &lt; max_snat 64&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arena_is_valid_clause_idx be bd &#10233; length be &#8804; sint64_max &#10233;
   bd &lt; max_snat 64&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arena_lifting</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>be</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bd</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_snat_def</span><span> </span><span>sint64_max_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>arena_lifting</span><span> </span><span>arena_is_valid_clause_idx_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>vmtf_mark_to_rescore_clause_fast_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry2 (isa_vmtf_mark_to_rescore_clause)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[&#955;((N, _), _). length N &#8804; sint64_max]<span class="hidden">&#8681;</span><sub>a</sub>
       arena_fast_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint64_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>arena_is_valid_clause_idx_le_uint64_max</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_clause_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_eq_nfoldli</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>while_upt_while_direct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nres_monad3</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>vmtf_mark_to_rescore_also_reasons_fast_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry3 (isa_vmtf_mark_to_rescore_also_reasons)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[&#955;(((_, N), _), _). length N &#8804; sint64_max]<span class="hidden">&#8681;</span><sub>a</sub>
      trail_pol_fast_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> arena_fast_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> out_learned_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> vmtf_remove_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;
      vmtf_remove_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>image_image</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span> </span><span>in_diffD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>    </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isa_vmtf_mark_to_rescore_also_reasons_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>while_eq_nfoldli</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>while_upt_while_direct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(64)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>nres_monad3</span><span> </span><span>case_option_split</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">experiment</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_llvm</span></span><span>
</span><span>  </span><span>ns_vmtf_dequeue_code</span><span>
</span><span>  </span><span>atoms_hash_del_code</span><span>
</span><span>  </span><span>atoms_hash_insert_code</span><span>
</span><span>  </span><span>update_next_search_impl</span><span>
</span><span>  </span><span>ns_vmtf_dequeue_code</span><span>
</span><span>  </span><span>vmtf_en_dequeue_fast_code</span><span>
</span><span>  </span><span>vmtf_rescale_code</span><span>
</span><span>  </span><span>current_stamp_impl</span><span>
</span><span>  </span><span>isa_vmtf_flush_fast_code</span><span>
</span><span>  </span><span>isa_vmtf_mark_to_rescore_code</span><span>
</span><span>  </span><span>isa_vmtf_unset_code</span><span>
</span><span>  </span><span>vmtf_mark_to_rescore_and_unset_code</span><span>
</span><span>  </span><span>find_decomp_wl_imp_fast_code</span><span>
</span><span>  </span><span>vmtf_rescore_fast_code</span><span>
</span><span>  </span><span>find_decomp_wl_imp&#39;_fast_code</span><span>
</span><span>  </span><span>vmtf_mark_to_rescore_clause_fast_code</span><span>
</span><span>  </span><span>vmtf_mark_to_rescore_also_reasons_fast_code</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">1775f91f0787 </td><td align="center">271ed48b </td><td align="center">Mo 20 Jn 2020 16:45:39 CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


