<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Watched_Literals_Transition_System (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Watched_Literals_Transition_System</h1>

<span class="command">theory</span> <span class="name">Watched_Literals_Transition_System</span><br/>
<span class="keyword">imports</span> <a href="WB_More_Refinement.html"><span class="name">WB_More_Refinement</span></a> <a href="../CDCL/CDCL_W_Abstract_State.html"><span class="name">CDCL_W_Abstract_State</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Watched_Literals_Transition_System</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>WB_More_Refinement</span><span> </span><span>CDCL.CDCL_W_Abstract_State</span><span>
</span><span>    </span><span>CDCL.CDCL_W_Restart</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Two-Watched Literals&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Rule-based system&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Types and Transitions System&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Types and accessing functions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>twl_clause</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>TWL_Clause</span><span> </span><span class="delimiter">(</span><span>watched</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;v</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>unwatched</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;v</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>clause</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a twl_clause &#8658; &#39;a :: {plus}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause (TWL_Clause W UW) = W + UW&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a :: {plus} twl_clause multiset &#8658; &#39;a multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses C &#8801; clause `# C&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>twl_cls</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause twl_clause&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>twl_clss</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_cls multiset&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>clauses_to_update</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v literal &#215; &#39;v twl_cls) multiset&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>lit_queue</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>twl_st</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;v clause) ann_lits &#215; &#39;v twl_clss &#215; &#39;v twl_clss &#215;
    &#39;v clause option &#215; &#39;v clauses &#215; &#39;v clauses &#215;  &#39;v clauses_to_update &#215; &#39;v lit_queue&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; (&#39;v, &#39;v clause) ann_lit list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail (M, _, _, _, _, _, _, _) = M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>clauses_to_update</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; (&#39;v literal &#215; &#39;v twl_cls) multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update (_, _, _, _, _, _, WS, _) = WS&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>set_clauses_to_update</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v literal &#215; &#39;v twl_cls) multiset &#8658; &#39;v twl_st &#8658; &#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_clauses_to_update WS (M, N, U, D, NE, UE, _, Q) = (M, N, U, D, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>literals_to_update</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v lit_queue&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update (_, _, _, _, _, _, _, Q) = Q&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>set_literals_to_update</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v lit_queue &#8658; &#39;v twl_st &#8658; &#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_literals_to_update Q (M, N, U, D, NE, UE, WS, _) = (M, N, U, D, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>set_conflict</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause &#8658; &#39;v twl_st &#8658; &#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_conflict D (M, N, U, _, NE, UE, WS, Q) = (M, N, U, Some D, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_conflict</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v clause option&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict (M, N, U, D, NE, UE, WS, Q) = D&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_clss&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses (M, N, U, D, NE, UE, WS, Q) = N + U&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>unit_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v clause multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_clss (M, N, U, D, NE, UE, WS, Q) = NE + UE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>unit_init_clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_init_clauses (M, N, U, D, NE, UE, WS, Q) = NE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_all_init_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v clause multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_init_clss (M, N, U, D, NE, UE, WS, Q) = clause `# N + NE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_learned_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_clss&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_learned_clss (M, N, U, D, NE, UE, WS, Q) = U&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_init_learned_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_init_learned_clss (_, N, U, _, _, UE, _) = UE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_all_learned_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_learned_clss (_, N, U, _, _, UE, _) = clause `# U + UE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_all_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v clause multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_clss (M, N, U, D, NE, UE, WS, Q) = clause `# N + NE + clause `# U + UE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>update_clause</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause (TWL_Clause W UW) L L&#39; =
  TWL_Clause (add_mset L&#39; (remove1_mset L W)) (add_mset L (remove1_mset L&#39; UW))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  When updating clause, we do it non-deterministically: in case of duplicate clause in the two
  sets, one of the two can be updated (and it does not matter), contrary to an if-condition.
  In later refinement, we know where the clause comes from and update it.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>update_clauses</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a multiset twl_clause multiset &#215; &#39;a multiset twl_clause multiset &#8658;
  &#39;a multiset twl_clause &#8658; &#39;a &#8658; &#39;a &#8658;
  &#39;a multiset twl_clause multiset &#215; &#39;a multiset twl_clause multiset &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N &#10233; update_clauses (N, U) D L L&#39; (add_mset (update_clause D L L&#39;) (remove1_mset D N), U)&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# U &#10233; update_clauses (N, U) D L L&#39; (N, add_mset (update_clause D L L&#39;) (remove1_mset D U))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>update_clausesE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clauses (N, U) D L L&#39; (N&#39;, U&#39;)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The Transition System&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We ensure that there are always &#8727;&#8249;2&#8250; watched literals and that there are different. All
  clauses containing a single literal are put in \&lt;^term&gt;&#8249;NE&#8250; or \&lt;^term&gt;&#8249;UE&#8250;.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>cdcl_twl_cp</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>pop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp (M, N, U, None, NE, UE, {#}, add_mset L Q)
    (M, N, U, None, NE, UE, {#(L, C)|C &#8712;# N + U. L &#8712;# watched C#}, Q)&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>propagate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp (M, N, U, None, NE, UE, add_mset (L, D) WS, Q)
    (Propagated L&#39; (clause D) # M, N, U, None, NE, UE, WS, add_mset (-L&#39;) Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched D = {#L, L&#39;#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L &#8712;# unwatched D. -L &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp (M, N, U, None, NE, UE, add_mset (L, D) WS, Q)
    (M, N, U, Some (clause D), NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched D = {#L, L&#39;#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L &#8712;# unwatched D. -L &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>delete_from_working</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp (M, N, U, None, NE, UE, add_mset (L, D) WS, Q) (M, N, U, None, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712;# clause D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>update_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp (M, N, U, None, NE, UE, add_mset (L, D) WS, Q)
    (M, N&#39;, U&#39;, None, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched D = {#L, L&#39;#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# unwatched D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M K &#8744; K &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clauses (N, U) D L K (N&#39;, U&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;The condition \&lt;^term&gt;&#8249;-L &#8712; lits_of_l M&#8250; is already implied by \&lt;^term&gt;&#8249;valid&#8250; invariant.&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>cdcl_twl_cpE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We do not care about the \&lt;^term&gt;&#8249;literals_to_update&#8250; literals.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>cdcl_twl_o</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>decide</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o (M, N, U, None, NE, UE, {#}, {#}) (Decided L # M, N, U, None, NE, UE, {#}, {#-L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atms_of_mm (clause `# N + NE)&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>skip</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o (Propagated L C&#39; # M, N, U, Some D, NE, UE, {#}, {#})
  (M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8800; {#}&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>resolve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o (Propagated L C # M, N, U, Some D, NE, UE, {#}, {#})
  (M, N, U, Some (cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.resolve_cls L D C), NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (Propagated L C # M) (remove1_mset (-L) D) = count_decided M&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>backtrack_unit_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o (M, N, U, Some D, NE, UE, {#}, {#})
  (Propagated L {#L#} # M1, N, U, None, NE, add_mset {#L#} UE, {#}, {#-L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = get_maximum_level M D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level M (D&#39; - {#L#}) &#8801; i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K = i + 1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; = {#L#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# (N + U) + NE + UE &#8872;pm D&#39;&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>backtrack_nonunit_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o (M, N, U, Some D, NE, UE, {#}, {#})
     (Propagated L D&#39; # M1, N, add_mset (TWL_Clause {#L, L&#39;#} (D&#39; - {#L, L&#39;#})) U, None, NE, UE,
       {#}, {#-L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = get_maximum_level M D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level M (D&#39; - {#L#}) &#8801; i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K = i + 1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8800; {#L#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# (N + U) + NE + UE &#8872;pm D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712;# D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="comment">&#8213; &#8249;\&lt;^term&gt;&#8249;L&#39;&#8250; is the new watched literal&#8250;</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L&#39; = i&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>cdcl_twl_oE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>cdcl_twl_stgy</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>cp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S S&#39; &#10233; cdcl_twl_stgy S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>other&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S S&#39; &#10233; cdcl_twl_stgy S S&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>cdcl_twl_stgyE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition of the Two-watched Literals Invariants&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definitions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The structural invariants states that there are at most two watched elements, that the watched
  literals are distinct, and that there are 2 watched literals if there are at least than two
  different literals in the full clauses.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>struct_wf_twl_cls</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v multiset twl_clause &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls (TWL_Clause W UW) &#10231;
   size W = 2 &#8743; distinct_mset (W + UW)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, C, NE, UE, Q) =
  (M, clause `# N + NE, clause `# U + UE,  C)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>twl_st</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conversions simp rules&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;) = get_trail S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail S&#39; &#8800; [] &#10233; cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.hd_trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;) = hd (get_trail S&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;) = get_conflict S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The invariant on the clauses is the following:
  &#9642; the structure is correct (the watched part is of length exactly two).
  &#9642; if we do not have to update the clause, then the invariant holds.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>twl_is_an_exception</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a multiset twl_clause &#8658; &#39;a multiset &#8658;
     (&#39;b &#215; &#39;a multiset twl_clause) multiset &#8658; bool&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_is_an_exception C Q WS &#10231;
   (&#8707;L. L &#8712;# Q &#8743; L &#8712;# watched C) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_blit</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;b) ann_lits &#8658; &#39;a clause &#8658; &#39;a literal &#8658; bool&#8250;</span></span></span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_blit M D L &#10231; (L &#8712;# D &#8743; L &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_blit</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;b) ann_lits &#8658; &#39;a clause &#8658; &#39;a literal &#8658; bool&#8250;</span></span></span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M D L&#39; &#10231; (&#8707;L. is_blit M D L &#8743; get_level M L &#8804; get_level M L&#39;)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This invariant state that watched literals are set at the end and are not swapped with an
  unwatched literal later.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>twl_lazy_update</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;b) ann_lits &#8658; &#39;a twl_cls &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M (TWL_Clause W UW) &#10231;
  (&#8704;L. L &#8712;# W &#10230; -L &#8712; lits_of_l M &#10230; &#172;has_blit M (W+UW) L &#10230;
    (&#8704;K &#8712;# UW. get_level M L &#8805; get_level M K &#8743; -K &#8712; lits_of_l M))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  If one watched literals has been assigned to false (\&lt;^term&gt;&#8249;-L &#8712; lits_of_l M&#8250;) and the clause
  has not yet been updated (\&lt;^term&gt;&#8249;L&#39; &#8713; lits_of_l M&#8250;: it should be removed either by
  updating &#8249;L&#8250;, propagating &#8249;L&#39;&#8250;, or marking the conflict), then the literals \&lt;^term&gt;&#8249;L&#8250; is of
  maximal level.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>watched_literals_false_of_max_level</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;b) ann_lits &#8658; &#39;a twl_cls &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M (TWL_Clause W UW) &#10231;
  (&#8704;L. L &#8712;# W &#10230; -L &#8712; lits_of_l M &#10230; &#172;has_blit M (W+UW) L &#10230;
    get_level M L = count_decided M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  This invariants talks about the enqueued literals:
  &#9642; the working stack contains a single literal;
  &#9642; the working stack and the \&lt;^term&gt;&#8249;literals_to_update&#8250; literals are false with respect to the
   trail and there are no duplicates;
  &#9642; and the latter condition holds even when \&lt;^term&gt;&#8249;WS = {#}&#8250;.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>no_duplicate_queued</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued (M, N, U, D, NE, UE, WS, Q) &#10231;
  (&#8704;C C&#39;. C &#8712;# WS &#10230; C&#39; &#8712;# WS &#10230; fst C = fst C&#39;) &#8743;
  (&#8704;C. C &#8712;# WS &#10230; add_mset (fst C) Q &#8838;# uminus `# lit_of `# mset M) &#8743;
  Q &#8838;# uminus `# lit_of `# mset M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_duplicate_queued_alt_def</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S =
    ((&#8704;C C&#39;. C &#8712;# clauses_to_update S &#10230; C&#39; &#8712;# clauses_to_update S &#10230; fst C = fst C&#39;) &#8743;
     (&#8704;C. C &#8712;# clauses_to_update S &#10230;
       add_mset (fst C) (literals_to_update S) &#8838;# uminus `# lit_of `# mset (get_trail S)) &#8743;
     literals_to_update S &#8838;# uminus `# lit_of `# mset (get_trail S))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>distinct_queued</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued (M, N, U, D, NE, UE, WS, Q) &#10231;
  distinct_mset Q &#8743;
  (&#8704;L C. count WS (L, C) &#8804; count (N + U) C)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  These are the conditions to indicate that the 2-WL invariant does not hold and is not
  \&lt;^term&gt;&#8249;literals_to_update&#8250;.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>clauses_to_update_prop</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop Q M (L, C) &#10231;
      (L &#8712;# watched C &#8743; -L &#8712; lits_of_l M &#8743; L &#8713;# Q &#8743; &#172;has_blit M (clause C) L)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  This invariants talks about the enqueued literals:
  &#9642; all clauses that should be updated are in \&lt;^term&gt;&#8249;WS&#8250; and are repeated often enough in it.
  &#9642; if \&lt;^term&gt;&#8249;WS = {#}&#8250;, then there are no clauses to updated that is not enqueued;
  &#9642; all clauses to updated are either in \&lt;^term&gt;&#8249;WS&#8250; or \&lt;^term&gt;&#8249;Q&#8250;.

  The first two conditions are written that way to please Isabelle.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>clauses_to_update_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M, N, U, None, NE, UE, WS, Q) &#10231;
     (&#8704;L C. ((L, C) &#8712;# WS &#10230; {#(L, C)| C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} &#8838;# WS)) &#8743;
     (&#8704;L. WS = {#} &#10230; {#(L, C)| C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} = {#}) &#8743;
     (&#8704;L C. C &#8712;# N + U &#10230; L &#8712;# watched C &#10230; -L &#8712; lits_of_l M &#10230; &#172;has_blit M (clause C) L &#10230;
       (L, C) &#8713;# WS &#10230; L &#8712;# Q)&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M, N, U, D, NE, UE, WS, Q) &#10231; True&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  This is the invariant of the 2WL structure: if one watched literal is false, then all unwatched
  are false.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>twl_exception_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658;  &#39;v twl_cls &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M, N, U, None, NE, UE, WS, Q) C &#10231;
    (&#8704;L. L &#8712;# watched C &#10230; -L &#8712; lits_of_l M &#10230; &#172;has_blit M (clause C) L &#10230;
      L &#8713;# Q &#10230; (L, C) &#8713;# WS &#10230;
      (&#8704;K &#8712;# unwatched C. -K &#8712; lits_of_l M))&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M, N, U, D, NE, UE, WS, Q) C &#10231; True&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>twl_st_exception_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv (M, N, U, D, NE, UE, WS, Q) &#10231;
  (&#8704;C &#8712;# N + U. twl_exception_inv (M, N, U, D, NE, UE, WS, Q) C)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Candidats for propagation (i.e., the clause where only one literals is non
  assigned) are enqueued.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>propa_cands_enqueued</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M, N, U, None, NE, UE, WS, Q) &#10231;
    (&#8704;L C. C &#8712;# N+U &#10230; L &#8712;# clause C &#10230; M &#8872;as CNot (remove1_mset L (clause C)) &#10230;
      undefined_lit M L &#10230;
      (&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS))&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M, N, U, D, NE, UE, WS, Q) &#10231; True&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>confl_cands_enqueued</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M, N, U, None, NE, UE, WS, Q) &#10231;
     (&#8704;C &#8712;# N + U. M &#8872;as CNot (clause C) &#10230;
       (&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS))&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M, N, U, Some _, NE, UE, WS, Q) &#10231;
     True&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This invariant talk about the decomposition of the trail and the invariants that holds in
  these states.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>past_invs</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs (M, N, U, D, NE, UE, WS, Q) &#10231;
    (&#8704;M1 M2 K. M = M2 @ Decided K # M1 &#10230; (
      (&#8704;C &#8712;# N + U. twl_lazy_update M1 C &#8743;
        watched_literals_false_of_max_level M1 C &#8743;
        twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C) &#8743;
      confl_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#}) &#8743;
      propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#}) &#8743;
      clauses_to_update_inv (M1, N, U, None, NE, UE, {#}, {#})))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>past_invs.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>twl_st_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv (M, N, U, D, NE, UE, WS, Q) &#10231;
  (&#8704;C &#8712;# N + U. struct_wf_twl_cls C) &#8743;
  (&#8704;C &#8712;# N + U. D = None &#10230; &#172;twl_is_an_exception C Q WS &#10230; (twl_lazy_update M C)) &#8743;
  (&#8704;C &#8712;# N + U. D = None &#10230; watched_literals_false_of_max_level M C)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_st_inv_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S &#10231;
  (&#8704;C &#8712;# get_clauses S. struct_wf_twl_cls C) &#8743;
  (&#8704;C &#8712;# get_clauses S. get_conflict S = None &#10230;
     &#172;twl_is_an_exception C (literals_to_update S) (clauses_to_update S) &#10230;
     (twl_lazy_update (get_trail S) C)) &#8743;
  (&#8704;C &#8712;# get_clauses S. get_conflict S = None &#10230;
     watched_literals_false_of_max_level (get_trail S) C)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;All the unit clauses are all propagated initially except when we have found a conflict of
  level \&lt;^term&gt;&#8249;0::nat&#8250;.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>entailed_clss_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv (M, N, U, D, NE, UE, WS, Q) &#10231;
    (&#8704;C &#8712;# NE + UE.
      (&#8707;L. L &#8712;# C &#8743; (D = None &#8744; count_decided M &gt; 0 &#10230; get_level M L = 0 &#8743; L &#8712; lits_of_l M)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  \&lt;^term&gt;&#8249;literals_to_update&#8250; literals are of maximum level and their negation is in the trail.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>valid_enqueued</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued (M, N, U, C, NE, UE, WS, Q) &#10231;
  (&#8704;(L, C) &#8712;# WS. L &#8712;# watched C &#8743; C &#8712;# N + U &#8743; -L &#8712; lits_of_l M &#8743;
     get_level M L = count_decided M) &#8743;
  (&#8704;L &#8712;# Q. -L &#8712; lits_of_l M &#8743; get_level M L = count_decided M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Putting invariants together:&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>twl_struct_invs</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S &#10231;
    (twl_st_inv S &#8743;
    valid_enqueued S &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) &#8743;
    twl_st_exception_inv S &#8743;
    no_duplicate_queued S &#8743;
    distinct_queued S &#8743;
    confl_cands_enqueued S &#8743;
    propa_cands_enqueued S &#8743;
    (get_conflict S &#8800; None &#10230; clauses_to_update S = {#} &#8743; literals_to_update S = {#}) &#8743;
    entailed_clss_inv S &#8743;
    clauses_to_update_inv S &#8743;
    past_invs S)
  &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>twl_stgy_invs</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S &#10231;
     cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) &#8743;
     cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict_non_zero_unless_level_0 (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Initial properties&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_is_an_exception_add_mset_to_queue</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_is_an_exception C (add_mset L Q) WS &#10231;
  (twl_is_an_exception C Q WS &#8744; (L &#8712;# watched C))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_is_an_exception_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_is_an_exception_add_mset_to_clauses_to_update</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_is_an_exception C Q (add_mset (L, D) WS) &#10231; (twl_is_an_exception C Q WS &#8744; C = D)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_is_an_exception_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_is_an_exception_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;twl_is_an_exception C {#} {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_is_an_exception_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_inv_empty_trail</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level [] C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update [] C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cases C; auto&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>WS_nempty</span><span> </span><span>WS_empty</span><span> </span><span>Q</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L C. (L, C) &#8712;# WS &#10233; {#(L, C)| C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L. WS = {#} &#10233; {#(L, C)| C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L C. C &#8712;# N + U &#10233; L &#8712;# watched C &#10233; -L &#8712; lits_of_l M &#10233; &#172;has_blit M (clause C) L &#10233;
       (L, C) &#8713;# WS &#10233; L &#8712;# Q&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M, N, U, None, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;C. C &#8712;# N + U &#10233; struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>twl_st_inv_empty_trail</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ([], N, U, C, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>twl_inv_empty_trail</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>no_duplicate_queued_no_queued</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued (M, N, U, D, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_distinct_queued_no_queued</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued ([], N, U, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_st_inv_add_mset_clauses_to_update</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv (M, N, U, None, NE, UE, WS, Q)
  &#10231; twl_st_inv (M, N, U, None, NE, UE, add_mset (L, D) WS, Q) &#8743;
    (&#172; twl_is_an_exception D Q WS &#10230;twl_lazy_update M D)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_add_mset_to_clauses_to_update</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_st_simps</span><span class="delimiter">:</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv (M, N, U, D, NE, UE, WS, Q) &#10231;
  (&#8704;C &#8712;# N + U. struct_wf_twl_cls C &#8743;
    (D = None &#10230; (&#172;twl_is_an_exception C Q WS &#10230; twl_lazy_update M C) &#8743;
    watched_literals_false_of_max_level M C))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>propa_cands_enqueued_unit_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M, N, U, C, add_mset L NE, UE, WS, Q) &#10231;
    propa_cands_enqueued (M, N, U, C, {#}, {#}, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M, N, U, C, NE, add_mset L UE, WS, Q) &#10231;
    propa_cands_enqueued (M, N, U, C, {#}, {#}, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>past_invs_enqueud</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs (M, N, U, D, NE, UE, WS, Q) &#10231;
  past_invs (M, N, U, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>confl_cands_enqueued_unit_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M, N, U, C, add_mset L NE, UE, WS, Q) &#10231;
    confl_cands_enqueued (M, N, U, C, {#}, {#}, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M, N, U, C, NE, add_mset L UE, WS, Q) &#10231;
    confl_cands_enqueued (M, N, U, C, {#}, {#}, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_inv_decomp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>lazy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; = M3 @ M2 @ [Decided K]&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MM&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M&#39; @ M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_M_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = get_level M1 L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LM</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M&#39; L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_dup_append_in_atm_notin</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>use</span><span> </span><span>that</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: M M&#39; defined_lit_map&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>lev_L_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = get_level M1 L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>image_Un</span><span> </span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C</span><span> </span><span>twl_lazy_update.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (W+UW) L&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_L_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = get_level M1 L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL</span><span> </span><span>n_d</span><span> </span><span>lev_M_M1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (W+UW) L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>b</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_blit M (W+UW) L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>lev_L&#39;_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L&#39; &#8804; get_level M L&#8250;</span></span></span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712; lits_of_l M&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span>MM&#39;</span><span> </span><span>W</span><span> </span><span>lev_L_M1</span><span> </span><span>lev_M_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L&#39; &#8712; atm_of ` lits_of_l M&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;M&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided K &#8712;set (dropWhile (&#955;S. atm_of (lit_of S) &#8800; atm_of K&#39;) M&#39;)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8712; lits_of_l M&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M&#39;</span><span> </span><span>append_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>last_in_set_dropWhile</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>use</span><span> </span><span>that</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: lits_of_def M&#39; MM&#39;&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L&#39; &gt; count_decided M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MM&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty_conv</span><span> </span><span>get_level_def</span><span> </span><span>count_decided_def</span><span>
</span><span>              </span><span>lits_of_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_M_M1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>uL</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>lev_L&#39;_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#UW. get_level M1 K &#8804; get_level M1 L &#8743; -K &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>K&#39;&#39;</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712;# UW&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>lev_K&#39;_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K&#39;&#39; &#8804; get_level M L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>uK&#39;_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-K&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span>W</span><span> </span><span>uL</span><span> </span><span>L&#39;M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C</span><span> </span><span>MM&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK&#39;_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK&#39;_M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M&#39;</span><span> </span><span>MM&#39;</span><span> </span><span>n_d</span><span> </span><span>uL</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M1</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>defined_lit_no_dupD</span><span> </span><span>in_lits_of_l_defined_litD</span><span>
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K&#39;&#39; = get_level M1 K&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit M&#39; K&#39;&#39;&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K&#39;&#39; &#8800; get_level M1 K&#39;&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MM&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>K&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K&#39;&#39; &#8800; get_level M1 K&#39;&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M&#39; K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M&#39; K&#39;&#39; + count_decided M1 &#8804; get_level M1 L&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K&#39;_L</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lev_L_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MM&#39;</span><span> </span><span>get_level_skip_end</span><span class="delimiter">[</span><span>OF</span><span> </span><span>True</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1 &#8804; get_level M1 L&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M1 L = count_decided M1&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>le_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided K &#8712; set (dropWhile (&#955;S. atm_of (lit_of S) &#8800; atm_of K&#39;&#39;) M&#39;)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M&#39;</span><span> </span><span>append_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>last_in_set_dropWhile</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>use</span><span> </span><span>True</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: lits_of_def M&#39; MM&#39; defined_lit_map&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M&#39;</span><span> </span><span>filter_empty_conv</span><span> </span><span>get_level_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M1 K&#39;&#39; &#8804; get_level M1 L &#8743; -K&#39;&#39; &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_M_M1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>uL</span><span class="delimiter">]</span><span> </span><span>lev_K&#39;_L</span><span> </span><span>uK&#39;_M</span><span> </span><span>uK&#39;_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_blit_Cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>blit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M C L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (K # M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit (K # M) C L&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_blit M C L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L&#39; &#8804; get_level M L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>blit</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_blit (K # M) C L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (K # M) L&#39; &#8804; get_level (K # M) L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>has_blit_def</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_blit_Cons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_blit (K # M) C L &#10231; (L = lit_of K &#8743; lit_of K &#8712;# C) &#8744; is_blit M C L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_blit_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_has_blit_propagate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit (Propagated L D # M) (W + UW) La &#10233;
    undefined_lit M L &#10233; no_dup M &#10233; &#172;has_blit M (W + UW) La&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_blit_def</span><span> </span><span>get_level_cons_if</span><span>
</span><span>    </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span>
</span><span>     </span><span>split</span><span class="delimiter">:</span><span>  </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>atm_lit_of_set_lits_of_l</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>defined_lit_map</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>atm_lit_of_set_lits_of_l</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>defined_lit_map</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_has_blit_propagate&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit (Propagated L D # M) (clause C) La &#10233;
    undefined_lit M L &#10233; no_dup M &#10233; &#172;has_blit M (clause C) La&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_has_blit_propagate</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched C&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unwatched C&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_has_blit_decide</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit (Decided L # M) (W + UW) La &#10233;
    undefined_lit M L &#10233; no_dup M &#10233; &#172;has_blit M (W + UW) La&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_blit_def</span><span> </span><span>get_level_cons_if</span><span>
</span><span>    </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span>
</span><span>     </span><span>split</span><span class="delimiter">:</span><span>  </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>defined_lit_map</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>le_SucI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>defined_lit_map</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>le_SucI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_has_blit_decide&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit (Decided L # M) (clause C) La &#10233;
    undefined_lit M L &#10233; no_dup M &#10233; &#172;has_blit M (clause C) La&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_has_blit_decide</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched C&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unwatched C&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_lazy_update_Propagated</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (Propagated L D # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lazy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M (TWL_Clause W UW)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update (Propagated L D # M) (TWL_Clause W UW)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_lazy_update.simps</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>La</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>    </span><span>La</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>uL_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- La &#8712; lits_of_l (Propagated L D # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>b</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit (Propagated L D # M) (W + UW) La&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (W + UW) La&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_has_blit_propagate</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- La &#8712; lits_of_l M &#10230; (&#8704;K&#8712;#UW. get_level M K &#8804; get_level M La &#8743; - K &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span>assms</span><span> </span><span>b&#39;</span><span> </span><span>uL_M</span><span> </span><span>La</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_lazy_update.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#UW. get_level M K &#8804; get_level M La &#8743; -K &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; -L&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = -L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b&#39;</span><span> </span><span>uL_M</span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>list.set</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lits_of_insert</span><span> </span><span>insert_iff</span><span> </span><span>uminus_lit_swap</span><span class="delimiter">)</span><span>
</span><span>      </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#UW. get_level (Propagated L D # M) K &#8804; get_level (Propagated L D # M) La &#8743;
             -K &#8712; lits_of_l (Propagated L D # M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit (Propagated L D # M) (W + UW) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# W+UW&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>b</span><span> </span><span>1</span><span> </span><span>b&#39;</span><span> </span><span>uL_M</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>          </span><span>count_decided_ge_get_level</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit (Propagated L D # M) (W + UW) (-L)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>La</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>b</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L D # M&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uminus_lit_swap</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma lazy_update_Propagated: &#8249;- L&#39; &#8713;# watched C &#10233; watched_literals_false_of_max_level M C&#10233;
  twl_lazy_update (Propagated L&#39; D # M) C&#8250;
  by (cases C) (auto simp: count_decided_ge_get_level get_level_cons_if)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pair_in_image_Pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(La, C) &#8712; Pair L ` D &#10231; La = L &#8743; C &#8712; D&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>image_Pair_subset_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# A &#8838;# Pair L `# B &#10231; A &#8838;# B&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset (L, x) (Pair L `# B) = Pair L `# (remove1_mset x B)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, x) &#8712;# Pair L `# B &#10230; x &#8712;# B&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>diff_single_trivial</span><span> </span><span>image_mset_remove1_mset_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>B</span><span class="delimiter">)</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_subset_eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_image_mset_Pair2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count {#(L, x). L &#8712;# M x#} (L, C) = (if x = C then count (M x) L else 0)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (M C) L = count {#L. L&#8712;#M C#} L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8230; = count ((&#955;L. Pair L C) `# {#L. L&#8712;#M C#}) ((&#955;L. Pair L C) L)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>count_image_mset_inj</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count {#(L, C). L &#8712;# {#L. L &#8712;# M C#}#} (L, C) = count (M C) L&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8800; C&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>not_in_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>count_image_mset</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lit_of_inj_on_no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M &#10233; inj_on (&#955;x. - lit_of x) (set M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_dup_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ws</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>twl_cp_twl_st_exception_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_cp_clauses_to_update</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>twl_excep</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>no_dup</span><span> </span><span>ws</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>_</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_is_an_exception_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span> </span><span>image_constant_conv</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>        </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ws</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (watched C) L &#8804; 1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>size_2_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_le_count</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8721;x&#8712;#N+U. count {#(L, x). L &#8712;# watched x#} (a, b)) &#8804; count (N+U) b&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>count_sum_mset_if_1_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_mset_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_image_mset_Pair2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NU = N + U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span> </span><span>multiset_filter_mono2</span><span> </span><span>image_Pair_subset_mset</span><span>
</span><span>        </span><span>clauses_to_update_prop.simps</span><span> </span><span>NU</span><span> </span><span>filter_mset_empty_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>unw</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl_excep</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ws</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>propagate.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;s&#8712;#clause `# U. &#172; tautology s&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_D</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>no_dup_consistentD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N + U = add_mset D NU&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_N_U</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit (Propagated L&#39; (add_mset L (add_mset L&#39; x2)) # M)
              (add_mset L (add_mset L&#39; x2)) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>lev_L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: get_level_cons_if&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>HH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;clauses_to_update_prop (add_mset (-L&#39;) Q) (Propagated L&#39; (clause D) # M) (L, D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L Q &#8838;# {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: lit_of_inj_on_no_dup distinct_map no_dup_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# Q&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_add_mset</span><span> </span><span>distinct_mset_union</span><span> </span><span>subset_mset.le_iff_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause D) L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>undef</span><span> </span><span>unw</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_blit_def</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_q_p_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# add_mset D NU. clauses_to_update_prop Q M (L, C)#} &#8838;# add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q_p_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_Q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;La C. C &#8712;# add_mset D NU &#10230; La &#8712;# watched C &#10230; - La &#8712; lits_of_l M &#10230;
    &#172; has_blit M (clause C) La &#10230; (La, C) &#8713;# add_mset (L, D) WS &#10230; La &#8712;# Q&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ball_def</span><span> </span><span>twl_st_exception_inv.simps</span><span> </span><span>twl_exception_inv.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>J</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>watched_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J &#8712;# watched C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- J &#8712; lits_of_l (Propagated L&#39; (clause D) # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit (Propagated L&#39; (clause D) # M) (clause C) J&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J_notin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J &#8713;# add_mset (- L&#39;) Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(J, C) &#8713;# WS&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# unwatched C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (clause C) J&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_has_blit_propagate&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>J&#39;</span><span class="delimiter">]</span><span> </span><span>n_d</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8712; lits_of_l (Propagated L&#39; (clause D) # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_excep</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uminus_lit_swap</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>watched_C</span><span> </span><span>watched</span><span> </span><span>that</span><span> </span><span>J_notin</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8712; lits_of_l (Propagated L&#39; (clause D) # M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_nempty</span><span> </span><span>L&#39;&#39;</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39;&#39; = L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8839;#
      Pair L `# {#C &#8712;# NU.
        clauses_to_update_prop (add_mset (- L&#39;) Q) (Propagated L&#39; (clause D) # M) (L&#39;&#39;, C)#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>n_d</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_Pair_subset_mset</span><span> </span><span>multiset_filter_mono2</span><span> </span><span>clauses_to_update_prop.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_mset.dual_order.trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IH</span><span> </span><span>*</span><span class="delimiter">]</span><span>  </span><span>HH</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39;&#39; = L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_empty</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>IH_Q</span><span> </span><span>watched</span><span> </span><span>undef</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span>
</span><span>          </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched</span><span> </span><span>add_mset_eq_add_mset</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Q</span><span> </span><span>LC&#39;</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1.prems&quot;</span></span></span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>HH</span><span> </span><span>Q.hyps</span><span> </span><span>HH</span><span> </span><span>IH_Q</span><span> </span><span>undef</span><span> </span><span>n_d</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>NU</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HH</span><span> </span><span>Q.IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Q.IH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Q.hyps</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>insert_iff</span><span>
</span><span>           </span><span>no_has_blit_propagate&#39;</span><span> </span><span>set_mset_add_mset_insert</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>L&#39;</span><span> </span><span>D</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl_excep</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ws</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N + U = add_mset D NU&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_N_U</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M (clause D) L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>use</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>lev_L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: count_decided_ge_get_level&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} &#8838;# add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NU</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_WS_NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8838;#
     add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NU</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_WS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_add_mset_notin_subset_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IH_WS</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_Q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;La C. C &#8712;# add_mset D NU &#10230; La &#8712;# watched C &#10230; - La &#8712; lits_of_l M &#10230;
    &#172;has_blit M (clause C) La &#10230; (La, C) &#8713;# add_mset (L, D) WS &#10230; La &#8712;# Q&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ball_def</span><span> </span><span>twl_st_exception_inv.simps</span><span> </span><span>twl_exception_inv.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>J</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>watched_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J &#8712;# watched C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- J &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause C) J&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J_notin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J &#8713;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(J, C) &#8713;# WS&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# unwatched C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_excep</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uminus_lit_swap</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; - L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>watched_C</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>C_WS</span><span> </span><span>IH_Q</span><span> </span><span>J_notin</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>C_WS</span><span> </span><span>J_notin</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>            </span><span>clauses_to_update_prop.simps</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_nempty</span><span> </span><span>K</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>KC</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LK</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = K&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>KC</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subset_add_mset_notin_subset_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IH_WS</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair K `# {#C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span>LK</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M (clause D) L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span> </span><span>watched</span><span> </span><span>add_mset_eq_add_mset</span><span>
</span><span>          </span><span>all_conj_distrib</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>1</span><span> </span><span>LK</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_empty</span><span> </span><span>K</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;clauses_to_update_prop Q M (K, D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH_Q</span><span> </span><span>WS_empty.IH</span><span> </span><span>watched</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M (clause D) L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH_WS&#39;</span><span> </span><span>IH_Q</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>NU</span><span> </span><span>filter_mset_empty_conv</span><span>
</span><span>          </span><span>all_conj_distrib</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH_WS&#39;</span><span> </span><span>IH_Q</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>NU</span><span> </span><span>filter_mset_empty_conv</span><span>
</span><span>          </span><span>all_conj_distrib</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Q</span><span> </span><span>K</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span> </span><span>ws</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>member_add_mset</span><span>
</span><span>       </span><span>is_blit_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl_excep</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ws</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>WD</span><span> </span><span>UWD</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = TWL_Clause WD UWD&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# remove1_mset L&#39; UWD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# WD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD L &#8805; 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) L &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713;# remove1_mset K UWD&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause D L K&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>consistent_interp_def</span><span>
</span><span>      </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>add_remove_WD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset K (remove1_mset L WD) &#8800; WD&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_iff</span><span> </span><span>trivial_add_mset_remove_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N + U = add_mset D NU&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_N_U</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_consistent_interp</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>consistent_interp_def</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_max_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L&#39; = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause D) L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_M</span><span> </span><span>w_max_D</span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>uL</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_ne_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8800; update_clause D L K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>add_remove_WD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N&#39;U&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#39; + U&#39; = add_mset ?D (remove1_mset D (N + U))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NU = remove1_mset D (N + U)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N + U = add_mset D NU&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>watched_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched ?D = {#K, L&#39;#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>add_remove_WD</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit (Propagated L&#39; C # M)
              (add_mset L (add_mset L&#39; x2)) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>x2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>lev_L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: count_decided_ge_get_level get_level_cons_if&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>HH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;clauses_to_update_prop (add_mset (-L&#39;) Q) (Propagated L&#39; (clause D) # M) (L, D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L Q &#8838;# {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: lit_of_inj_on_no_dup distinct_map no_dup_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LQ</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# Q&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_add_mset</span><span> </span><span>distinct_mset_union</span><span> </span><span>subset_mset.le_iff_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_q_p_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause D) L &#10233; clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LQ</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# add_mset D NU. clauses_to_update_prop Q M (L, C)#} &#8838;# add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause D) L &#10233; Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q_p_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH_Q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La C. C &#8712;# add_mset D NU &#10233; La &#8712;# watched C &#10233; - La &#8712; lits_of_l M &#10233;
    &#172;has_blit M (clause C) La &#10233; (La, C) &#8713;# add_mset (L, D) WS &#10233; La &#8712;# Q&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>blit_clss_to_upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M (clause D) L &#10233; &#172; clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} &#8838;# add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M (clause D) L &#10233;
      (L, D) &#8713;# Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q_M_L_WS</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NU</span><span> </span><span>w_q_p_D</span><span> </span><span>blit_clss_to_upd</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>subset_add_mset_notin_subset_mset</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_ne_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clss_upd_D</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause ?D = clause D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ball_def</span><span> </span><span>twl_st_exception_inv.simps</span><span> </span><span>twl_exception_inv.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>J</span><span> </span><span>K&#39;&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>watched_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J&#8712;# watched C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- J &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause C) J&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>J_notin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J &#8713;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(J, C) &#8713;# WS&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>K&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712;# unwatched C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_excep</span><span> </span><span>that</span><span> </span><span>*</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>C</span><span class="delimiter">]</span><span>  </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uminus_lit_swap</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>uK&#39;&#39;_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# N + U. clauses_to_update_prop Q M (L, C)#} &#8838;# add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span>
</span><span>            </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J = L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_q_p_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop Q M (L, C)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched_C</span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>K&#39;&#39;</span><span> </span><span>uK&#39;&#39;_M</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>conj_disj_distribR</span><span> </span><span>ex_disj_distrib</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>watched_C</span><span> </span><span>CD</span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>J_notin</span><span> </span><span>K&#39;&#39;</span><span> </span><span>uK&#39;&#39;_M</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>L_M</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>NU</span><span> </span><span>CD</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, C) &#8712;# Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#}&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>w_q_p_L</span><span> </span><span>D_ne_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>NU</span><span> </span><span>CD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, C) &#8712;# WS&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_WS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J &#8800; L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop Q M (L, C)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched_C</span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>K&#39;&#39;</span><span> </span><span>uK&#39;&#39;_M</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>conj_disj_distribR</span><span> </span><span>ex_disj_distrib</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>watched_C</span><span> </span><span>CD</span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>J_notin</span><span> </span><span>K&#39;&#39;</span><span> </span><span>uK&#39;&#39;_M</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>L_M</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_WS</span><span> </span><span>D_N_U</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_WS</span><span> </span><span>D_N_U</span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>J_notin</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J &#8800; L&#8250;</span></span></span><span> </span><span>that</span><span> </span><span>watched_C</span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>JL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;J = L&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CD</span><span> </span><span>J</span><span> </span><span>J&#39;</span><span> </span><span>watched_C</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>D</span><span> </span><span>uK_M</span><span> </span><span>undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8800; K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span>D</span><span> </span><span>L&#39;_L&#39;_UWD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CD</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K&#39;&#39;_unwatched_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712;#  remove1_mset K (unwatched D) &#8744; K&#39;&#39; = L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause C = clause D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>blit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (clause D) L&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>that</span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;x La xa. x &#8712;# N + U &#10233;
            La &#8712;# watched x &#10233; - La &#8712; lits_of_l M &#10233;
            &#172;has_blit M (clause x) La &#10233; La &#8713;# Q &#10233; (La, x) &#8713;# add_mset (L, D) WS &#10233;
            xa &#8712;# unwatched x &#10233; - xa &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_excep</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>twl_st_exception_inv.simps</span><span> </span><span>Ball_def</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span>is_blit_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LL&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;D_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L&#39;, D) &#8713;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>LL&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8712;# unwatched D &#10233; - xa &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (clause D) L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xa</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>use</span><span> </span><span>D_N_U</span><span> </span><span>watched</span><span> </span><span>LL&#39;</span><span> </span><span>that</span><span> </span><span>L&#39;D_WS</span><span> </span><span>K&#39;&#39;</span><span> </span><span>that</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: add_mset_eq_add_mset L_M&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>        </span><span class="delimiter">(</span><span>unwatched_unqueued</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712;# remove1_mset K (unwatched D)&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="delimiter">(</span><span>KL</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; = L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K&#39;&#39;_unwatched_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>KL</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>unwatched_unqueued</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713;# Q&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>JL</span><span> </span><span>J_notin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>blit</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span> </span><span>D_N_U</span><span> </span><span>watched</span><span> </span><span>LL&#39;</span><span> </span><span>L&#39;D_WS</span><span> </span><span>K&#39;&#39;</span><span> </span><span>J</span><span> </span><span>J&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>L_M</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_nempty</span><span> </span><span>K&#39;&#39;</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>KC</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LK</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = K&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>KC</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;clauses_to_update_prop Q M (K&#39;&#39;, update_clause D K&#39;&#39; K)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uK_M</span><span> </span><span>struct_D</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>LK</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `#  {#C &#8712;# N&#39; + U&#39;. clauses_to_update_prop Q M (L, C)#} &#8838;#
      Pair L `#  {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_Pair_subset_mset</span><span> </span><span>LK</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LK</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span> </span><span>watched</span><span> </span><span>NU</span><span>
</span><span>          </span><span>add_mset_eq_add_mset</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair K&#39;&#39; `#  {#C &#8712;# N&#39; + U&#39;. clauses_to_update_prop Q M (K&#39;&#39;, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q_M_L_WS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LK</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_empty</span><span> </span><span>K&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>IH_Q</span><span> </span><span>uL</span><span> </span><span>uK_M</span><span> </span><span>L_M</span><span> </span><span>watched</span><span> </span><span>L_ne_L&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>NU</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>clauses_to_update_prop.simps</span><span>
</span><span>          </span><span>add_mset_eq_add_mset</span><span> </span><span>watched_D</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Q</span><span> </span><span>K&#39;</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>C</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uK&#39;_M</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uK&#39;&#39;_M</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>KC_WS</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>watched_C</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span>K&#39;</span><span class="delimiter">]</span><span> </span><span>CD</span><span> </span><span>watched</span><span> </span><span>uK_M</span><span> </span><span>L&#39;</span><span>  </span><span>L_ne_L&#39;</span><span> </span><span>L_M</span><span> </span><span>uK&#39;_M</span><span> </span><span>uK&#39;&#39;_M</span><span>
</span><span>        </span><span>Q</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>NU</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>        </span><span class="delimiter">(</span><span>KL</span><span class="delimiter">)</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; = L&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="delimiter">(</span><span>K&#39;L&#39;</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; = L&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>watched_C</span><span> </span><span>CD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>KL</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, C) &#8712;# Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#}&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CD</span><span> </span><span>C</span><span> </span><span>w_q_p_D</span><span> </span><span>uK&#39;&#39;_M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span> </span><span>D_ne_D</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, C) &#8712;# WS&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q_M_L_WS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KC_WS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>K&#39;L&#39;</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>CD</span><span> </span><span>watched_C</span><span> </span><span>uK&#39;_M</span><span> </span><span>uK&#39;&#39;_M</span><span> </span><span>KC_WS</span><span> </span><span>L_ne_L&#39;</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L&#39;, D) &#8713;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>L_ne_L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>IH_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span>  </span><span>CD</span><span> </span><span>watched</span><span> </span><span>watched_D</span><span> </span><span>watched_C</span><span> </span><span>watched</span><span> </span><span>uK_M</span><span> </span><span>L&#39;</span><span>
</span><span>          </span><span>L_ne_L&#39;</span><span> </span><span>L_M</span><span> </span><span>uK&#39;_M</span><span> </span><span>uK&#39;&#39;_M</span><span> </span><span>D_ne_D</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU</span><span> </span><span>N&#39;U&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>all_conj_distrib</span><span> </span><span>imp_conjR</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_twl_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>twl_excep</span><span> </span><span>no_dup</span><span> </span><span>wq</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_is_an_exception_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>unw</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>exception</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL&#39;_M</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>propagate.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>watched_max</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level (Propagated L&#39; (clause D) # M) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>n_d</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;twl_is_an_exception C (add_mset (- L&#39;) Q) WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C Q (add_mset (L, D) WS)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*     have &#8249;&#172; twl_is_an_exception C Q (add_mset (L, D) WS)&#8250;
      using D_N_U excep
      unfolding twl_is_an_exception_add_mset_to_queue
          twl_is_an_exception_add_mset_to_clauses_to_update
      by (auto simp add: twl_st_inv.simps twl_is_an_exception_add_mset_to_queue
          twl_is_an_exception_add_mset_to_clauses_to_update) *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>D_N_U</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update (Propagated L&#39; (clause D) # M) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>excep</span><span> </span><span>uL&#39;_M</span><span> </span><span>twl</span><span> </span><span>undef</span><span> </span><span>n_d</span><span> </span><span>uL&#39;_M</span><span> </span><span>unw</span><span> </span><span>watched_max</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>count_decided_ge_get_level</span><span>
</span><span>          </span><span>twl_is_an_exception_add_mset_to_queue</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span> </span><span>no_has_blit_propagate</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>uL&#39;_M</span><span> </span><span>unw</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>uL&#39;_M</span><span> </span><span>unw</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>uL&#39;_M</span><span> </span><span>unw</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>uL&#39;_M</span><span> </span><span>unw</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>L&#39;</span><span> </span><span>D</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tauto</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;twl_is_an_exception C Q WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C Q (add_mset (L, D) WS)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>excep</span><span> </span><span>twl</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>has_blit_def</span><span>
</span><span>          </span><span>twl_is_an_exception_add_mset_to_queue</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>count_decided_ge_get_level</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span> </span><span>no_has_blit_propagate</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>excep</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span>
</span><span>          </span><span>twl_is_an_exception_add_mset_to_clauses_to_update</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_C</span><span> </span><span>twl_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl_excep</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wq</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>WD</span><span> </span><span>UWD</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = TWL_Clause WD UWD&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# remove1_mset L&#39; UWD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# WD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD L &#8805; 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) L &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713;# remove1_mset K UWD&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause D L K&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>consistent_interp_def</span><span>
</span><span>      </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>add_remove_WD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset K (remove1_mset L WD) &#8800; WD&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_iff</span><span> </span><span>trivial_add_mset_remove_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cls_D_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause ?D = clause D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>watched</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_consistent_interp</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>consistent_interp_def</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_max_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>D</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>K</span><span> </span><span>struct_D</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>D</span><span> </span><span>L&#39;_UWD</span><span> </span><span>L&#39;_L&#39;_UWD</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>that</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D&#39;</span><span> </span><span>struct_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;C. C &#8712;# N+U &#10233; &#172; twl_is_an_exception C Q WS &#10233; C &#8800; D &#10233;
       twl_lazy_update M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_is_an_exception_add_mset_to_clauses_to_update</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>that</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_max_D</span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>uK_M</span><span> </span><span>distinct_consistent_interp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d</span><span class="delimiter">]</span><span> </span><span>uL</span><span> </span><span>K</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>consistent_interp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;twl_is_an_exception C Q WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C Q WS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_inv_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M, N, U, None, NE, UE, add_mset (L, D) WS, Q) D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_excep</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_exception_inv.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (clause D) L &#10233;
         L &#8713;# Q &#10233; (L, D) &#8713;# add_mset (L, D) WS &#10233; (&#8704;K&#8712;#unwatched D. - K &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_exception_inv.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NU_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# N+U. clauses_to_update_prop Q M (L, C)#} &#8838;# add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: lit_of_inj_on_no_dup distinct_map no_dup_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L Q &#8838;# {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LQ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# Q&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_add_mset</span><span> </span><span>distinct_mset_union</span><span> </span><span>subset_mset.le_iff_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_lazy_update.simps</span><span> </span><span>CD</span><span> </span><span>D</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>K&#39;</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8712;# WD&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39; &#8712; lits_of_l M&#8250;</span></span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (WD + UWD) K&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; update_clause D L K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>add_remove_WD</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (add_mset L (add_mset L&#39; UWD)) L&#39; &#10233;
         has_blit M (add_mset L (add_mset L&#39; UWD)) L &#10233; False&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8712;# WD&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (WD + UWD) K&#39;&#8250;</span></span></span><span>
</span><span>          </span><span>lev_L</span><span> </span><span>w_max_D</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_blit_def</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N+U = add_mset D NU&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>D_N_U</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# remove1_mset D (N + U)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>C_D&#39;</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_clauses.simps</span><span> </span><span>NU</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N+U = add_mset C (add_mset D NU&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NU</span><span> </span><span>multi_member_split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uL</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (WD + UWD) K&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8712;# WD&#8250;</span></span></span><span> </span><span>LQ</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>D</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>H</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, D) &#8712;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NU_WS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CD</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#UWD. get_level M K &#8804; get_level M K&#39; &#8743; - K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span>excep_WS</span><span> </span><span>*</span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?D = TWL_Clause {#K, L&#39;#} (add_mset L (remove1_mset K UWD))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>mset_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#K, L&#39;#} + add_mset L (remove1_mset K UWD) = clause D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>cls_D_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L&#39; = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M &#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (clause D) L&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_M</span><span> </span><span>w_max_D</span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>uL</span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C. C &#8712;# WS &#10230; fst C = L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>undef</span><span> </span><span>D</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* excep wq *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_mset_union</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L&#39;, TWL_Clause {#L, L&#39;#} UWD) &#8713;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wq</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>D_N_U</span><span class="delimiter">]</span><span> </span><span>struct_D</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>undef</span><span> </span><span>D</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* excep wq *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M &#10233; &#172; has_blit M (add_mset L (add_mset L&#39; UWD)) L&#39; &#10233;
              L&#39; &#8712;# Q &#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wq</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>D_N_U</span><span class="delimiter">]</span><span> </span><span>struct_D</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>undef</span><span> </span><span>D</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* excep wq *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_mset_union</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M &#10233; &#172; has_blit M (add_mset L (add_mset L&#39; UWD)) L&#39; &#10233;
             False&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>D_N_U</span><span class="delimiter">]</span><span> </span><span>struct_D</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>undef</span><span> </span><span>D</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  wq *)</span></span></span></span></span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_mset_union</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_remove1_mset</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8712;# remove1_mset K UWD &#10231; K&#39; &#8800; K &#8743; K&#39; &#8712;# UWD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>L&#39;_L&#39;_UWD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>D</span><span> </span><span>in_remove1_mset_neq</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>undef</span><span> </span><span>D</span><span> </span><span>w_max_D</span><span> </span><span>H</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_lazy_update.simps</span><span> </span><span>D&#39;</span><span> </span><span>mset_D&#39;</span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uK_M</span><span> </span><span>D</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>lev_L</span><span> </span><span>count_decided_ge_get_level</span><span>
</span><span>            </span><span>in_remove1_mset</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_no_duplicate_queued</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>no_dup</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span> </span><span>image_image</span><span> </span><span>subset_mset.less_imp_le</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>mset_subset_eq_insertD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_mset_Pair</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (Pair L `# C) &#10231; distinct_mset C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_image_mset_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause `# C) &#10233; distinct_mset C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_distinct_queued</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>no_dup</span><span> </span><span>dist</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>c_dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_Pair</span><span> </span><span>count_image_mset_Pair</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>image_mset_union</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>propagate.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#39; &#8713;# Q&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mset_subset_eqD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Suc_leD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Suc_leD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_queued.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset Q&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>le_SucI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (count WS (L, D)) &#8804; count N D + count U D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LC</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count WS (La, Ca) &#8804; count N Ca + count U Ca&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(La , Ca) &#8800; (L, D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Ca</span><span> </span><span>La</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>le_SucI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count WS (K&#39;&#39;, C) &#8804; count (N&#39; + U&#39;) C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8800; L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count WS (K&#39;&#39;, C) = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LD</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>le_SucI</span><span class="delimiter">;</span><span>
</span><span>            </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LC</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>le_SucI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_valid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>no_dup</span><span> </span><span>dist</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>filter_union_mset</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_taut</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>mset_subset_eq_insertD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_simps</span><span> </span><span>Ball_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>mset_subset_eq_insertD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_enqueued.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>L</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# Q&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>KC</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal &#215; &#39;a twl_cls&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>LC_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;KC &#8712;# WS&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>LC</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;KC = (K&#39;&#39;, C)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>KC</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LC_WS</span><span> </span><span>valid</span><span> </span><span>LC</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C_ne_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case KC of (L, C) &#8658; L &#8712;# watched C &#8743; C &#8712;# N&#39; + U&#39; &#8743; - L &#8712; lits_of_l M &#8743;
        get_level M L = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>use</span><span> </span><span>valid</span><span> </span><span>LC</span><span> </span><span>LC_WS</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: in_remove1_mset_neq elim!: update_clausesE&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K&#39;&#39;_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; = L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>LC_WS</span><span> </span><span>LC</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (count WS (L, D)) &#8804; count N D + count U D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_DN_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# remove1_mset D (N+U)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LC_WS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LC</span><span> </span><span>K&#39;&#39;_L</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_D_N</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# remove1_mset D N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8713;# U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# remove1_mset D (U + N)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_DN_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# U + remove1_mset D N&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>add_mset_remove_trivial</span><span> </span><span>insert_DiffM</span><span>
</span><span>            </span><span>union_mset_add_mset_right</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# remove1_mset D N&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_D_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# remove1_mset D U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8713;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# remove1_mset D (U + N)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_DN_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + remove1_mset D U&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_DN_U</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# remove1_mset D U&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case KC of (L, C) &#8658; L &#8712;# watched C &#8743; C &#8712;# N&#39; + U&#39; &#8743; - L &#8712; lits_of_l M &#8743;
        get_level M L = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>valid</span><span> </span><span>LC_WS</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: LC D_D_N that in_remove1_mset_neq
          dest!: D_D_U elim!: update_clausesE&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case KC of (L, C) &#8658; L &#8712;# watched C &#8743; C &#8712;# N&#39; + U&#39; &#8743; - L &#8712; lits_of_l M &#8743;
        get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CD</span><span> </span><span>C_ne_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_propa_cands_enqueued</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ws</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>twl_excep</span><span> </span><span>no_dup</span><span> </span><span>cands</span><span> </span><span>ws</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cands</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (remove1_mset K (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# add_mset L Q)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744;
        (&#8707;La. (La, C) &#8712;# Pair L `# {#C &#8712;# N + U. L &#8712;# watched C#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>false</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>excep</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cands</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>to_upd</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL&#39;_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>propagate.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;_M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L&#39; (clause D) # M &#8872;as CNot (remove1_mset K (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (Propagated L&#39; (clause D) # M) K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_K_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M K&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>      </span><span class="delimiter">(</span><span>no_L&#39;</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (remove1_mset K (clause C))&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="delimiter">(</span><span>L&#39;</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#39; &#8712;# remove1_mset K (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insertE</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span> </span><span>lit_of.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lits_of_insert</span><span>
</span><span>          </span><span>true_annots_CNot_lit_of_notin_skip</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;a. L&#39;a &#8712;# watched C &#8743; L&#39;a &#8712;# add_mset (- L&#39;) Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>no_L&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;#  Q) &#8744; (&#8707;La. (La, C) &#8712;# add_mset (L, D) WS)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span>C</span><span> </span><span>K</span><span> </span><span>undef_K_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span>add_mset_add_single</span><span> </span><span>clause.simps</span><span> </span><span>in_CNot_implies_uminus</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>              </span><span>in_remove1_mset_neq</span><span> </span><span>multi_member_this</span><span> </span><span>no_L&#39;</span><span> </span><span>that</span><span> </span><span>twl_clause.exhaust</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>              </span><span>union_iff</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>L&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = L&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>L&#39;_M_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span>L&#39;</span><span> </span><span>undef</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>clause.simps</span><span> </span><span>in_CNot_implies_uminus</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>in_lits_of_l_defined_litD</span><span>
</span><span>              </span><span>in_remove1_mset_neq</span><span> </span><span>insert_iff</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span> </span><span>lits_of_insert</span><span>
</span><span>              </span><span>twl_clause.exhaust_sel</span><span> </span><span>uminus_not_id&#39;</span><span> </span><span>uminus_of_uminus_id</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>undef_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>L&#39;_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>          </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#39;a. L&#39;a &#8712;# watched C &#10230; L&#39;a &#8800; - L&#39; &#8743; L&#39;a &#8713;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L. (L, C) &#8713;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C (add_mset (- L&#39;) Q) WS&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv (Propagated L&#39; (clause D) # M, N, U, None, NE, UE, WS, add_mset (- L&#39;) Q)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_cp_twl_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>excep</span><span> </span><span>no_dup</span><span> </span><span>to_upd</span><span class="delimiter">]</span><span>
</span><span>          </span><span>cdcl_twl_cp.propagate</span><span class="delimiter">[</span><span>OF</span><span> </span><span>propagate</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update (Propagated L&#39; (clause D) # M) C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>C_W_UW</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#a, b#}&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ua_or_ub</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8712; lits_of_l M &#8744; -b &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span>C_W_UW</span><span> </span><span>W</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#39;a. L&#39;a &#8712;# watched C &#10230; L&#39;a &#8800; - L&#39; &#8743; L&#39;a &#8713;# Q&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = a&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>            </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uab</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-b &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span>C_W_UW</span><span> </span><span>W</span><span> </span><span>that</span><span> </span><span>undef_K_M</span><span> </span><span>uL&#39;_M</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = a&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>              </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>uL&#39;_M</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uba</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span>C_W_UW</span><span> </span><span>W</span><span> </span><span>that</span><span> </span><span>undef_K_M</span><span> </span><span>uL&#39;_M</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = b&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>              </span><span>add_mset_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8800; L&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-b &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span>C_W_UW</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;La L&#39;. watched C = {#La, L&#39;#} &#10230; - La &#8712; lits_of_l M &#10230;
           &#172;has_blit M (clause C) La &#10230; L&#39; &#8713; lits_of_l M &#10230;
          (&#8704;K&#8712;#unwatched C. - K &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>C</span><span> </span><span>CD</span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span>WS</span><span> </span><span>uab</span><span> </span><span>uba</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_mset_union</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched C = {#La, L&#39;&#39;#} &#10230;- La &#8712; lits_of_l M &#10230; &#172;has_blit M (clause C) La&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>L&#39;&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_CNot_implies_uminus</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>L&#39;_M_C</span><span class="delimiter">]</span><span>  </span><span>wf_C</span><span> </span><span>L&#39;</span><span> </span><span>uL&#39;_M</span><span> </span><span>undef_K_M</span><span> </span><span>undef</span><span> </span><span>uab</span><span> </span><span>uba</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W_UW</span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = K&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_blit_def</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>W</span><span>
</span><span>              </span><span>add_mset_eq_add_mset</span><span> </span><span>in_remove1_mset_neq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;a. &#10214;a &#8712; lits_of_l M; - a &#8712; lits_of_l M&#10215; &#10233; False&#8250;</span></span></span><span> </span><span>add_mset_remove_trivial</span><span>
</span><span>              </span><span>defined_lit_uminus</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>in_remove1_mset_neq</span><span> </span><span>undef</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;a. &#10214;a &#8712; lits_of_l M; - a &#8712; lits_of_l M&#10215; &#10233; False&#8250;</span></span></span><span> </span><span>add_mset_remove_trivial</span><span>
</span><span>              </span><span>defined_lit_uminus</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>in_remove1_mset_neq</span><span> </span><span>undef</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#unwatched C. - K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uab</span><span> </span><span>uba</span><span> </span><span>W</span><span> </span><span>C_W_UW</span><span> </span><span>ua_or_ub</span><span> </span><span>wf_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W_UW</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>L&#39;</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>              </span><span>Q</span><span> </span><span>clause.simps</span><span> </span><span>in_diffD</span><span> </span><span>propagate.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>twl_clause.collapse</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cands</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>L&#39;</span><span> </span><span>D</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cands</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ws</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;_M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (remove1_mset K (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;La. La = L &#8743; C = D &#8744; (La, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span>L&#39;_M_C</span><span> </span><span>undef_K</span><span> </span><span>watched</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span>
</span><span>        </span><span>local.K</span><span> </span><span>n_d</span><span> </span><span>K</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span>add_mset_eq_add_mset</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>no_dup_consistentD</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl_excep</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cands</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ws</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>13</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>WD</span><span> </span><span>UWD</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = TWL_Clause WD UWD&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# remove1_mset L&#39; UWD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# WD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD L &#8805; 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) L &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713;# remove1_mset K UWD&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause D L K&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>consistent_interp_def</span><span>
</span><span>      </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>add_remove_WD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset K (remove1_mset L WD) &#8800; WD&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_iff</span><span> </span><span>trivial_add_mset_remove_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>D</span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_ne_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8800; update_clause D L K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>add_remove_WD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_consistent_interp</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>consistent_interp_def</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_max_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clause_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause ?D = clause D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>K2</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K2 &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;_M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (remove1_mset K2 (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M K2&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;La. (La, C) &#8712;# WS)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span>*</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>L&#39;_M_C</span><span> </span><span>add_diff_cancel_left&#39;</span><span>
</span><span>            </span><span>clause.simps</span><span> </span><span>clause_D</span><span> </span><span>in_diffD</span><span> </span><span>in_remove1_mset_neq</span><span> </span><span>that</span><span>
</span><span>            </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>uK_M</span><span> </span><span>undef_K</span><span>
</span><span>            </span><span>update_clause.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#8712;#remove1_mset K2 (clause ?D). defined_lit M L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_D</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K2 = K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>undef_K</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>that</span><span> </span><span>clause_D</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D</span><span> </span><span>clause.simps</span><span> </span><span>in_remove1_mset_neq</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>union_iff</span><span>
</span><span>            </span><span>update_clause.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL&#39;_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>L&#39;_M_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; L&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8800; L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ((&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;_C_WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L&#39;, C) &#8713;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# add_mset (L, TWL_Clause WD UWD) WS &#10230;
        C&#39; &#8712;# add_mset (L, TWL_Clause WD UWD) WS &#10230;
        fst C = fst C&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>C&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D</span><span> </span><span>no_duplicate_queued.simps</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, TWL_Clause WD UWD)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L&#39;, TWL_Clause {#L, L&#39;#} UWD)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L&#39;, TWL_Clause {#L, L&#39;#} UWD) &#8712;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>watched</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?D &#8800; D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>L</span><span> </span><span>K</span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M, N, U, None, NE, UE, add_mset (L, D) WS, Q) D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_excep</span><span> </span><span>*</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = TWL_Clause {#L, L&#39;#} UWD &#10233;
          WD = {#L, L&#39;#} &#10233;
          &#8704;L&#8712;#remove1_mset K UWD.
             - L &#8712; lits_of_l M &#10233;
          &#172;has_blit M (add_mset L (add_mset L&#39; UWD)) L&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL</span><span> </span><span>uL&#39;_M</span><span> </span><span>n_d</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M&#8250;</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>no_dup_consistentD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_remove1_mset_neq</span><span> </span><span>Ball_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_remove1_mset_neq</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# unwatched D. -K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>L&#39;_M_C</span><span> </span><span>L&#39;_C_WS</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>uL&#39;_M</span><span> </span><span>L_M</span><span> </span><span>uL</span><span> </span><span>twl_exception_inv.simps</span><span>
</span><span>            </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span> </span><span>notin</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>update_clause.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N + U = add_mset D NU&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_N_U</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N&#39;U&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#39; + U&#39; = add_mset ?D (remove1_mset D (N + U))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L Q &#8838;# {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: lit_of_inj_on_no_dup distinct_map no_dup_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# Q&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_add_mset</span><span> </span><span>distinct_mset_union</span><span> </span><span>subset_mset.le_iff_add</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M (clause D) L &#10233; False&#8250;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* CVC4 is amazing! *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>K</span><span> </span><span>L&#39;_M_C</span><span> </span><span>has_blit_def</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>insert_DiffM</span><span> </span><span>insert_iff</span><span>
</span><span>            </span><span>is_blit_def</span><span> </span><span>n_d</span><span> </span><span>no_dup_consistentD</span><span> </span><span>set_mset_add_mset_insert</span><span> </span><span>that</span><span>
</span><span>            </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span>undef_K</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_q_p_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="delimiter">(</span><span>use</span><span> </span><span>uL</span><span> </span><span>undef</span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: Decided_Propagated_in_iff_in_lits_of_l&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# add_mset D NU. clauses_to_update_prop Q M (L, C)#} &#8838;#
          add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q_p_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, D) &#8712;# Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>D_ne_D</span><span> </span><span>w_q_p_D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched D &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, D) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_confl_cands_enqueued</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ws</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confl_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39;  &#8712;# add_mset L Q)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744;
        (&#8707;La. (La, C) &#8712;# Pair L `# {#C &#8712;# N + U. L &#8712;# watched C#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL&#39;_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confl_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;_M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L&#39; (clause D) # M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>        </span><span class="delimiter">(</span><span>no_L&#39;</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>L&#39;</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#39; &#8712;# clause C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insertE</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span> </span><span>lit_of.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lits_of_insert</span><span>
</span><span>          </span><span>true_annots_CNot_lit_of_notin_skip</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;a. L&#39;a &#8712;# watched C &#8743; L&#39;a &#8712;# add_mset (- L&#39;) Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>no_L&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;La. (La, C) &#8712;# add_mset (L, D) WS)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span>add_mset_add_single</span><span> </span><span>clause.simps</span><span> </span><span>in_CNot_implies_uminus</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>              </span><span>multi_member_this</span><span> </span><span>no_L&#39;</span><span> </span><span>twl_clause.exhaust</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>              </span><span>union_iff</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>L&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713;# watched C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>L&#39;</span><span> </span><span>clause.simps</span><span>
</span><span>            </span><span>in_CNot_implies_uminus</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>insertE</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span> </span><span>lits_of_insert</span><span> </span><span>twl_clause.exhaust_sel</span><span>
</span><span>            </span><span>uminus_not_id&#39;</span><span> </span><span>uminus_of_uminus_id</span><span> </span><span>undef</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>          </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#39;a. L&#39;a &#8712;# watched C &#10230; L&#39;a &#8800; - L&#39; &#8743; L&#39;a &#8713;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L. (L, C) &#8713;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C (add_mset (- L&#39;) Q) WS&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv (Propagated L&#39; (clause D) # M, N, U, None, NE, UE, WS, add_mset (- L&#39;) Q)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_cp_twl_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>excep</span><span> </span><span>no_dup</span><span> </span><span>ws</span><span class="delimiter">]</span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update (Propagated L&#39; (clause D) # M) C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_C</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>C_W_UW</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#a, b#}&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ua_ub</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8712; lits_of_l M &#8744; -b &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span>C_W_UW</span><span> </span><span>W</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#39;a. L&#39;a &#8712;# watched C &#10230; L&#39;a &#8800; - L&#39; &#8743; L&#39;a &#8713;# Q&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = a&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>            </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uab</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-b &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span>C_W_UW</span><span> </span><span>W</span><span> </span><span>that</span><span> </span><span>uL&#39;_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = a&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uba</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span>C_W_UW</span><span> </span><span>W</span><span> </span><span>that</span><span> </span><span>uL&#39;_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = b&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-a &#8800; L&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-b &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#39;a. L&#39;a &#8712;# watched C &#10230; L&#39;a &#8800; - L&#39; &#8743; L&#39;a &#8713;# Q&#8250;</span></span></span><span> </span><span>W</span><span> </span><span>C_W_UW</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;La L&#39;. watched C = {#La, L&#39;#} &#10230; - La &#8712; lits_of_l M &#10230; L&#39; &#8713; lits_of_l M &#10230;
          &#172; has_blit M (clause C) La &#10230;(&#8704;K&#8712;#unwatched C. - K &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>C</span><span> </span><span>CD</span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span>WS</span><span> </span><span>uab</span><span> </span><span>uba</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>S</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (clause C) a&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M (clause C) b&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>undef</span><span> </span><span>L&#39;_M_C</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Clausal_Logic.uminus_lit_swap</span><span>
</span><span>              </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;a. &#10214;a &#8712; lits_of_l M; - a &#8712; lits_of_l M&#10215; &#10233; False&#8250;</span></span></span><span> </span><span>in_CNot_implies_uminus</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>              </span><span>in_lits_of_l_defined_litD</span><span> </span><span>insert_iff</span><span> </span><span>is_blit_def</span><span> </span><span>list.set</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lits_of_insert</span><span> </span><span>uL&#39;_M</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#unwatched C. - K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uab</span><span> </span><span>uba</span><span> </span><span>W</span><span> </span><span>C_W_UW</span><span> </span><span>ua_ub</span><span> </span><span>struct</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>L&#39;</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>              </span><span>Q</span><span> </span><span>clause.simps</span><span> </span><span>undef</span><span> </span><span>twl_clause.collapse</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>L&#39;</span><span> </span><span>D</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confl_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;_M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;La. La = L &#8743; C = D &#8744; (La, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;_M_C</span><span> </span><span>watched</span><span> </span><span>L&#39;</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_consistent_interp</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>consistent_interp_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>N&#39;U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>WD</span><span> </span><span>UWD</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = TWL_Clause WD UWD&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# remove1_mset L&#39; UWD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# WD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD L &#8805; 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) L &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713;# remove1_mset K UWD&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause D L K&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>consistent_interp_def</span><span>
</span><span>      </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>add_remove_WD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset K (remove1_mset L WD) &#8800; WD&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_iff</span><span> </span><span>trivial_add_mset_remove_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>D</span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_ne_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8800; update_clause D L K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>add_remove_WD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_consistent_interp</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>consistent_interp_def</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_max_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clause_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause ?D = clause D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confl_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;_M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;La. (La, C) &#8712;# WS)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cands</span><span> </span><span>*</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D</span><span> </span><span>L&#39;_M_C</span><span> </span><span>add_diff_cancel_left&#39;</span><span>  </span><span>clause.simps</span><span> </span><span>clause_D</span><span> </span><span>in_diffD</span><span>
</span><span>          </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>uK_M</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;La. (La, C) &#8712;# WS)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N + U = add_mset D NU&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_N_U</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N&#39;U&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#39; + U&#39; = add_mset ?D (remove1_mset D (N + U))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L Q &#8838;# {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset {#- lit_of x. x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: lit_of_inj_on_no_dup distinct_map no_dup_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# Q&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_add_mset</span><span> </span><span>distinct_mset_union</span><span> </span><span>subset_mset.le_iff_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M (clause D) L &#10233; False&#8250;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* CVC4 is amazing! *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>K</span><span> </span><span>L&#39;_M_C</span><span> </span><span>has_blit_def</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>insert_DiffM</span><span> </span><span>insert_iff</span><span>
</span><span>            </span><span>is_blit_def</span><span> </span><span>n_d</span><span> </span><span>no_dup_consistentD</span><span> </span><span>set_mset_add_mset_insert</span><span> </span><span>that</span><span>
</span><span>            </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_q_p_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop Q M (L, D)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="delimiter">(</span><span>use</span><span> </span><span>uL</span><span> </span><span>undef</span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: Decided_Propagated_in_iff_in_lits_of_l&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# add_mset D NU. clauses_to_update_prop Q M (L, C)#} &#8838;#
          add_mset (L, D) WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>NU</span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#} &#8838;# WS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q_p_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, D) &#8712;# Pair L `# {#C &#8712;# NU. clauses_to_update_prop Q M (L, C)#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>D_ne_D</span><span> </span><span>w_q_p_D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU</span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pair_in_image_Pair</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched D &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, D) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# Q) &#8744; (&#8707;L. (L, C) &#8712;# WS)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_past_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>past_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span> </span><span>twl_excep</span><span> </span><span>no_dup</span><span> </span><span>past_invs</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>past_invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>past_invs_enqueud</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>past_invs_enqueud</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>past_invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>propagate.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;a clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L&#39; (clause D) # M = M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = tl M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagated_cons_eq_append_decide_cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>past_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;a clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L&#39; (clause D) # M = M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = tl M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagated_cons_eq_append_decide_cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>L&#39;</span><span> </span><span>D</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>past_invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;a clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>past_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;a clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl_excep</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>past_invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>WD</span><span> </span><span>UWD</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = TWL_Clause WD UWD&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# remove1_mset L&#39; UWD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# WD&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD L &#8805; 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) L &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_L&#39;_UWD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713;# remove1_mset K UWD&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count UWD K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count (clause D) K &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_greater_zero_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_D</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_mset_count_less_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause D L K&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>consistent_interp_def</span><span>
</span><span>      </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>add_remove_WD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset K (remove1_mset L WD) &#8800; WD&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_iff</span><span> </span><span>trivial_add_mset_remove_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cls_D_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause ?D = clause D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>watched</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>uL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_consistent_interp</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>consistent_interp_def</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_max_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; + U&#39;&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;a clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2 @ Decided K&#39; # M1&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_L_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M1 L = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>get_level_cons_if</span><span>
</span><span>          </span><span>atm_of_notin_get_level_eq_0</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>defined_lit_no_dupD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_of_notin_get_level_eq_0</span><span> </span><span>defined_lit_no_dupD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_count_decided_gt_get_level</span><span> </span><span>add_Suc_right</span><span> </span><span>not_add_less2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past_invs</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>lazy_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M1 &#10233; &#172; has_blit M1 (add_mset L (add_mset L&#39; UWD)) L&#39; &#10233;
            (&#8704;K&#8712;#UWD. get_level M1 K &#8804; get_level M1 L&#39; &#8743; - K &#8712; lits_of_l M1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D</span><span> </span><span>twl_lazy_update.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>C</span><span> </span><span>past_invs</span><span> </span><span>that</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N&#39;, U&#39;, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>C</span><span> </span><span>twl</span><span> </span><span>past_invs</span><span> </span><span>M</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 ?D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>uK_M</span><span> </span><span>K</span><span> </span><span>lazy_L&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>lev_L_M1</span><span>
</span><span>              </span><span>all_conj_distrib</span><span> </span><span>add_mset_commute</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>uK_M</span><span> </span><span>K</span><span> </span><span>lazy_L&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>lev_L_M1</span><span>
</span><span>          </span><span>all_conj_distrib</span><span> </span><span>add_mset_commute</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N&#39;, U&#39;, None, NE, UE, {#}, {#}) ?D&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span>uK_M</span><span> </span><span>K</span><span> </span><span>lazy_L&#39;</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>lev_L_M1</span><span>
</span><span>           </span><span>all_conj_distrib</span><span> </span><span>add_mset_commute</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N&#39;, U&#39;, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#39; &#10233; C &#8712;# N &#8744; C = ?D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# U&#39; &#10233; C &#8712;# U &#8744; C = ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;a clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2 @ Decided K&#39; # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;M1 &#8872;as CNot (clause ?D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>uK_M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span>cls_D_D</span><span> </span><span>M</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M2 @ [Decided K&#39;]) L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_M</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span> </span><span>no_dup_def</span><span> </span><span>defined_lit_map</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">:</span><span> </span><span>mk_disjoint_insert</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L_M</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M1</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;M1 &#8872;as CNot (remove1_mset K&#39;&#39; (clause ?D))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K&#39;&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>uK_M</span><span> </span><span>watched</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; = L&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1, N&#39;, U&#39;, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N&#39;, U&#39;, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N + U = add_mset D NU&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_N_U</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NU_remove</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NU = remove1_mset D (N + U)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#39; + U&#39; = add_mset ?D (remove1_mset D (N + U))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N&#39;U&#39;</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N&#39;U&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#39;+U&#39; = add_mset ?D NU&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU_remove</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>watched_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched ?D = {#K, L&#39;#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>add_remove_WD</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past_invs</span><span> </span><span>D_N_U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span>twl_lazy_update.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>lazy_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M1 &#10233; &#172; has_blit M1 (add_mset L (add_mset L&#39; UWD)) L&#39; &#10233;
            (&#8704;K&#8712;#UWD. get_level M1 K &#8804; get_level M1 L&#39; &#8743; - K &#8712; lits_of_l M1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D</span><span> </span><span>twl_lazy_update.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL&#39;_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit M1 (clause (update_clause D L K)) L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>uK_M</span><span> </span><span>lazy_L&#39;</span><span> </span><span>that</span><span> </span><span>D</span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cls_D_D</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span> </span><span>UWD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1, N&#39;, U&#39;, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_nempty</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_empty</span><span> </span><span>K&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;clauses_to_update_prop {#} M1 (K&#39;&#39;, ?D)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M1</span><span> </span><span>uL&#39;_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>watched_D</span><span>
</span><span>            </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>NU</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>watched_D</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Q</span><span> </span><span>J</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_prop {#} M1 (L&#39;, D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L&#39; &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>that</span><span> </span><span>uL&#39;_M1</span><span> </span><span>Q.hyps</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span>cls_D_D</span><span>
</span><span>          </span><span>insert_DiffM</span><span> </span><span>w_q</span><span> </span><span>watched_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q</span><span> </span><span>watched_D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span>N&#39;U&#39;</span><span> </span><span>NU</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Invariants and the Transition System&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conflict and propagate&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>literals_to_update_measure</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; nat list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update_measure S = [size (literals_to_update S), size (clauses_to_update S)]&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_cp_propagate_or_conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) &#8744;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) &#8744;
    (state<span class="hidden">&#8681;</span><sub>W</sub>_of S = state<span class="hidden">&#8681;</span><sub>W</sub>_of T &#8743; (literals_to_update_measure T, literals_to_update_measure S) &#8712;
       lexn less_than 2)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lexn2_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_upd</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, add_mset (L, D) WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (Propagated L&#39; (clause D) # M, N, U, None, NE, UE, WS, add_mset (- L&#39;) Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;s&#8712;#clause `# U. &#172; tautology s&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate ?S ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause D&#8250;</span></span></span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span>clauses_def</span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_of.simps</span><span> </span><span>image_eqI</span><span>
</span><span>           </span><span>in_image_mset</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_upd</span><span> </span><span>watched</span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">;</span><span>
</span><span>         </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.state_simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>defined</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_upd</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, add_mset (L, D) WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, Some (clause D), NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>valid</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span>distinct_mset_set_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (unwatched D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_upd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict ?S ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause D&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span>clauses_def</span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_of.simps</span><span> </span><span>image_eqI</span><span>
</span><span>        </span><span>in_image_mset</span><span> </span><span>union_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>defined</span><span> </span><span>valid</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (unwatched D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span>
</span><span>         </span><span>trail.simps</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.state_simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lexn2_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unwatched</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause (update_clause D L K) = clause D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span>unwatched</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>diff_union_swap2</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>diff_union_swap2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, add_mset (L, D) WS, Q) =
    state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N&#39;, U&#39;, None, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(literals_to_update_measure (M, N&#39;, U&#39;, None, NE, UE, WS, Q),
       literals_to_update_measure (M, N, U, None, NE, UE, add_mset (L, D) WS, Q))
     &#8712; lexn less_than 2&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_clause</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_remove1_mset_if</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_clausesE</span><span>
</span><span>        </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lexn2_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>valid</span><span> </span><span>inv</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decide</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>U</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atm</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.decide (state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, {#}, {#}))
    (state<span class="hidden">&#8681;</span><sub>W</sub>_of (Decided L # M, N, U, None, NE, UE, {#}, {#-L#}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.decide_rule</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_eq_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.state_simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>skip</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>LD</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.bj</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.skip</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.skip_rule</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LD</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_eq_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.state_simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>resolve</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>LD</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;La mark a b. a @ Propagated La mark # b = Propagated L C # M &#10230;
      b &#8872;as CNot (remove1_mset La mark) &#8743; La &#8712;# mark&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>     </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LC</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.bj</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.resolve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.resolve_rule</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LC</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LD</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_eq_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.state_simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_unit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>L_D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>max_D&#39;_L</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D&#39;_D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NU_D&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>D&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, Some {#L#}, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (Propagated L {#L#} # M1, N, U, None, NE, add_mset {#L#} UE, {#}, {#L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.backtrack_lit_skiped</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span> </span><span>_</span><span> </span><span>K</span><span> </span><span>_</span><span> </span><span>M2</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = add_mset L (remove1_mset L D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M3 @ M2) K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1 = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_D</span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M3</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.bj</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.backtrack</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.backtrack_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L D&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L D&#39;&#8250;</span></span></span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_D&#39;_L</span><span> </span><span>L_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_D</span><span> </span><span>L_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D&#39;_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NU_D&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>clauses_def</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_eq_def</span><span> </span><span>state_def</span><span> </span><span>prod.inject</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_nonunit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>LD</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>max_lev</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D&#39;_D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NU_D&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_D&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span>-</span><span>12</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (Propagated L D # M1, N, U, None, NE, add_mset {#L#} UE, {#}, {#L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.backtrack_lit_skiped</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span> </span><span>_</span><span> </span><span>K</span><span> </span><span>_</span><span> </span><span>M2</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>inv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M3 @ M2) K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1 = i&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span>lev_L</span><span> </span><span>lev_K</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L (add_mset L&#39; (D&#39; - {#L, L&#39;#})) = D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span>L_D&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_diff_bothsides</span><span> </span><span>diff_single_eq_union</span><span> </span><span>insert_noteq_member</span><span> </span><span>mset_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L D&#39; = add_mset L&#39; (D&#39; - {#L, L&#39;#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>D</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>D</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.bj</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.backtrack</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.backtrack_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L D&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L D&#39;&#8250;</span></span></span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_lev</span><span> </span><span>L_D&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>get_maximum_level_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D&#39;_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mset_le_subtract</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NU_D&#39;</span><span> </span><span>L_D&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mset_le_subtract</span><span> </span><span>clauses_def</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_eq_def</span><span> </span><span>state_def</span><span> </span><span>prod.inject</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>lev_K</span><span> </span><span>count_M1</span><span> </span><span>L_D&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_cp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T &#10233; twl_struct_invs S &#10233;
  cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) &#8744;
  (state<span class="hidden">&#8681;</span><sub>W</sub>_of S = state<span class="hidden">&#8681;</span><sub>W</sub>_of T &#8743; (literals_to_update_measure T, literals_to_update_measure S)
   &#8712; lexn less_than 2)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>twl_cp_propagate_or_conflict</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.conflict&#39;</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.propagate&#39;</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_cp_conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T &#10233; get_conflict T &#8800; None &#10230;
     clauses_to_update T = {#} &#8743; literals_to_update T = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_cp_entailed_clss_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T &#10233; entailed_clss_inv S &#10233; entailed_clss_inv T&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pop</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>_</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv (M, N, U, None, NE, UE, add_mset (L, D) WS, Q)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L&#39; &#8800; atm_of L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>L_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L. L &#8712;# C &#8743; (None = None &#8744; 0 &lt; count_decided (Propagated L&#39; (clause D) # M) &#10230;
      get_level (Propagated L&#39; (clause D) # M) L = 0 &#8743;
      L &#8712; lits_of_l (Propagated L&#39; (clause D) # M))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>L_M</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>conflict</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>delete_from_working</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>update_clause</span><span> </span><span>D</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_cp_init_clss</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T &#10233; twl_struct_invs S &#10233; init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) = init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_more_init_clss</span><span> </span><span>cdcl_twl_cp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_cp_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T &#10233; twl_struct_invs S &#10233; twl_struct_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>twl_cp_twl_inv</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_cp_twl_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_cp_valid</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cdcl_twl_cp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span>
</span><span>      </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cdcl_twl_cp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_smaller_propa</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>twl_cp_twl_st_exception_inv</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_cp_no_duplicate_queued</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>twl_cp_distinct_queued</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>twl_cp_confl_cands_enqueued</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>twl_cp_propa_cands_enqueued</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp_conflict</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp_entailed_clss_inv</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_cp_clauses_to_update</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_cp_past_invs</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twl_struct_invs_no_false_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_false_clause (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS</span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, U, D, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;C. C &#8712;# N + U &#10233; struct_wf_twl_cls C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>entailed</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#} &#8713;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>entailed</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>entailed_clss_inv.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_mset_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause C = {#} &#10233; C &#8712;# N + U &#10233; False&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>set_mset_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_false_clause_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_cp_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T &#10233; twl_struct_invs S &#10233; twl_stgy_invs S &#10233; twl_stgy_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_stgy_invs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_conflict_non_zero_unless_level_0</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant</span><span>
</span><span>      </span><span>cdcl_twl_cp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate</span><span> </span><span>twl_cp_propagate_or_conflict</span><span>
</span><span>      </span><span>twl_struct_invs_def</span><span> </span><span>twl_struct_invs_no_false_clause</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The other rules&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>cdcl_twl_o_twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cdcl_twl_o_past_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decide</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>U</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atm</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (Decided K # M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defined_lit_map</span><span> </span><span>n_d</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a twl_cls&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>lazy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l (Decided K # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit (Decided K # M) (W + UW) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>False</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8800; K&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l M &#10233; &#172; has_blit M (W + UW) L &#10233; get_level M L = count_decided M &#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>W&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#L, L&#39;#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span>W</span><span> </span><span>size_2_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>W</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_single</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_has_blit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (W + UW) L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_has_blit_decide&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span> </span><span>M</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>L&#39;</span><span> </span><span>n_d</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# UW. -K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span> </span><span>False</span><span> </span><span>excep</span><span> </span><span>C</span><span> </span><span>W</span><span> </span><span>C_W</span><span> </span><span>L&#39;</span><span> </span><span>W</span><span> </span><span>n_d</span><span> </span><span>undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>all_conj_distrib</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>N</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M_CNot_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (remove1_mset L&#39; (clause C))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL</span><span> </span><span>False</span><span> </span><span>W&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_W</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712;# clause C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit M L&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L&#39;</span><span> </span><span>W&#39;</span><span> </span><span>False</span><span> </span><span>uL</span><span> </span><span>C_W</span><span> </span><span>L&#39;_C</span><span> </span><span>H</span><span> </span><span>no_has_blit</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO Proof *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>C_W</span><span> </span><span>L&#39;_C</span><span> </span><span>no_has_blit</span><span> </span><span>clause.simps</span><span>
</span><span>            </span><span>count_decided_ge_get_level</span><span> </span><span>has_blit_def</span><span> </span><span>is_blit_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_CNot_C</span><span> </span><span>W&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_W</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level (Decided K # M) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>watched_literals_false_of_max_level.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>        </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l (Decided K # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit (Decided K # M) (W + UW) L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L = K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>OF</span><span> </span><span>W</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (Decided K # M) L = count_decided (Decided K # M)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>exception</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C {#-K#} {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_le_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M Ka &#8804; Suc (count_decided M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Ka</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>le_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update (Decided K # M) C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span>Ball_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span>K&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>          </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l (Decided K # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit (Decided K # M) (W + UW) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>K&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8712;# UW&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L = K&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>OF</span><span> </span><span>W</span><span> </span><span>uL</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exception</span><span> </span><span>W</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_W</span><span> </span><span>twl_is_an_exception_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (Decided K # M) K&#39; &#8804; get_level (Decided K # M) L &#8743;
             -K&#39;  &#8712; lits_of_l (Decided K # M)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>K&#39;</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided K # M = M2 @ Decided K&#39; # M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = tl M2 @ Decided K&#39; # M1 &#8744; M = M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;M1 M2 K. M = M2 @ Decided K # M1 &#10230;
        twl_lazy_update M1 C &#8743; watched_literals_false_of_max_level M1 C &#8743;
        twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;a clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided K # M = M2 @ Decided K&#39; # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = tl M2 @ Decided K&#39; # M1 &#8744; M = M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands</span><span> </span><span>past</span><span> </span><span>propa_cands</span><span> </span><span>w_q</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>skip</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>resolve</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_unit_clause</span><span> </span><span>K&#39;</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span>-</span><span>5</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Propagated K&#39; {#K&#39;#} # M1, N, U, None, NE, add_mset {#K&#39;#} UE, {#}, {#- K&#39;#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated K&#39; {#K&#39;#} # M1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bt_twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o ?S ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.backtrack_unit_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack_unit_clause.hyps</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)  (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>invs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simp_all add: twl_struct_invs_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span> </span><span>invs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup ?M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; = M3 @ M2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2&#39; @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>M2&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_cands_M1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, add_mset {#K&#39;#} UE, {#}, {#- K&#39;#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>M1_CNot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot (remove1_mset L (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = remove1_mset L (clause C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D &#8712;# clause `# (N + U)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>M1_CNot</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>M&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa_def</span><span> </span><span>trail.simps</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- K&#39;#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a twl_cls&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>CW</span><span> </span><span>CUW</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause CW CUW&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>exception</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C {#-K&#39;#} {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>lazy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>watched_max</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>past</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_le_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M Ka &#8804; Suc (count_decided M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Ka</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>le_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Lev_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (?M1) K &#8804; count_decided M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>get_level_cons_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update ?M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO Proof *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lazy *)</span></span></span></span></span><span> </span><span>Lev_M1</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>exception</span><span> </span><span>twl</span><span> </span><span>n_d&#39;</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* unw *)</span></span></span></span></span><span> </span><span>watched_max</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* get_level_cons_if *)</span></span></span></span></span><span> </span><span>count_decided_ge_get_level</span><span>
</span><span>              </span><span>twl_is_an_exception_add_mset_to_queue</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span> </span><span>no_has_blit_propagate</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>get_level_skip_beginning</span><span> </span><span>get_level_take_beginning</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>get_level_skip_beginning</span><span> </span><span>get_level_take_beginning</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M&#39;</span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level ?M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_blit_Cons</span><span> </span><span>n_d&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_W</span><span> </span><span>get_level_cons_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1&#39;&#39;</span><span> </span><span>M2&#39;&#39;</span><span> </span><span>K&#39;&#39;</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?M1 = M2&#39;&#39; @ Decided K&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 = tl M2&#39;&#39; @ Decided K&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M2&#39;&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1&#39;&#39; C&#8250;</span></span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1&#39;&#39; C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span>M1</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1&#39;&#39;, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span>M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1&#39;&#39;, N, U, None, NE, add_mset {#K&#39;#} UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_exception_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1&#39;&#39; C&#8250;</span></span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1&#39;&#39; C&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1&#39;&#39;, N, U, None, NE, add_mset {#K&#39;#} UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1&#39;&#39;</span><span> </span><span>M2&#39;&#39;</span><span> </span><span>K&#39;&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?M1 = M2&#39;&#39; @ Decided K&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 = tl M2&#39;&#39; @ Decided K&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M2&#39;&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1&#39;&#39;, N, U, None, NE, add_mset {#K&#39;#} UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1&#39;&#39;, N, U, None, NE, add_mset {#K&#39;#} UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1&#39;&#39;, N, U, None, NE, add_mset {#K&#39;#} UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_nonunit_clause</span><span> </span><span>K&#39;</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>K&#39;&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>K&#39;_D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K&#39;_D&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated K&#39; D&#39; # M1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(?M1, N, add_mset (TWL_Clause {#K&#39;, K&#39;&#39;#} (D&#39; - {#K&#39;, K&#39;&#39;#})) U, None, NE, UE, {#},
   {#- K&#39;#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TWL_Clause {#K&#39;, K&#39;&#39;#} (D&#39; - {#K&#39;, K&#39;&#39;#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bt_twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o ?S ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.backtrack_nonunit_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack_nonunit_clause.hyps</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)  (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>invs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simp_all add: twl_struct_invs_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span> </span><span>invs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup ?M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; = M3 @ M2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2&#39; @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>M2&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M3 @ M2) K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1 = i&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K&#39;&#39;_ne_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8800; K&#39;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span>lev_K&#39;</span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>K&#39;&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset K&#39; (add_mset K&#39;&#39; (D&#39; - {#K&#39;, K&#39;&#39;#})) = D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset K&#39;&#39; (add_mset K&#39; (D&#39; - {#K&#39;, K&#39;&#39;#})) = D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span>K&#39;_D&#39;</span><span> </span><span>multi_member_split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_cands_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#- K&#39;&#39;#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>M1_CNot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot (remove1_mset L (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = remove1_mset L (clause C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D &#8712;# clause `# (N + U)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>M1_CNot</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>M&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa_def</span><span> </span><span>trail.simps</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- K&#39;&#39;#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_CNot_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot (remove1_mset K&#39; D&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting.simps</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK&#39;&#39;_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-K&#39;&#39; &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span>K&#39;&#39;_ne_K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_remove1_mset_neq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M3 @ M2 @ Decided K # []) K&#39;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>defined_lit_no_dupD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_M1_K&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M1 K&#39;&#39; = count_decided M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span>count_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a twl_cls&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + add_mset ?D U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset D&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>CW</span><span> </span><span>CUW</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause CW CUW&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>lazy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>watched_max</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>past</span><span> </span><span>M&#39;</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>past_invs.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>M1_CNot_D</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_D_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# remove1_mset K&#39; D&#39; &#10233; - L &#8712; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_K_D_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# D&#39; - {#K&#39;, K&#39;&#39;#} &#10233; - L &#8712; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>K&#39;_D&#39;</span><span> </span><span>add_mset_diff_bothsides</span><span> </span><span>add_mset_remove_trivial</span><span> </span><span>in_diffD</span><span> </span><span>mset_add</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>def_K&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit M1 K&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d&#39;</span><span> </span><span>uK&#39;&#39;_M1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>uK&#39;&#39;_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>lazy_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update ?M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>n_d&#39;</span><span> </span><span>uK&#39;&#39;_M1</span><span> </span><span>def_K&#39;&#39;</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>in_K_D_M1</span><span> </span><span>lev_M1_K&#39;&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>get_level_cons_if</span><span>
</span><span>          </span><span>atm_of_eq_atm_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>watched_max_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level ?M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>in_D_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>lev_M1_K&#39;&#39;</span><span> </span><span>get_level_cons_if</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_K_D_M1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; twl_is_an_exception C {#-K&#39;#} {#}&#8250;</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_le_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M Ka &#8804; Suc (count_decided M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Ka</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>le_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Lev_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (?M1) K &#8804; count_decided M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>get_level_cons_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update ?M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (Propagated K&#39; D&#39; # M1) K &#8804; get_level (Propagated K&#39; D&#39; # M1) L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L. L &#8712;# CW &#10230; - L &#8712; lits_of_l M1 &#10230; &#172; has_blit M1 (CW + CUW) L &#10230;
                get_level M1 L = count_decided M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# CW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# CUW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M1 (CW + CUW) L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Lev_M1</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>count_decided_ge_get_level</span><span> </span><span>get_level_skip_beginning</span><span> </span><span>get_level_take_beginning</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# CW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TWL_Clause CW CUW &#8712;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CW &#8800; {#K&#39;, K&#39;&#39;#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# CUW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; has_blit M1 (CW + CUW) L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO Proof *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lazy *)</span></span></span></span></span><span> </span><span>Lev_M1</span><span> </span><span>C_W</span><span> </span><span>that</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>C</span><span> </span><span>excep</span><span> </span><span>twl</span><span> </span><span>n_d&#39;</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* unw *)</span></span></span></span></span><span> </span><span>watched_max</span><span> </span><span>1</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* get_level_cons_if *)</span></span></span></span></span><span> </span><span>count_decided_ge_get_level</span><span>
</span><span>              </span><span>twl_is_an_exception_add_mset_to_queue</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>that</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span> </span><span>no_has_blit_propagate</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_lazy_update.simps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update ?M1 C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lazy_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>C</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level ?M1 C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>has_blit_Cons</span><span> </span><span>n_d&#39;</span><span> </span><span>C_W</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level ?M1 C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watched_max_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1&#39;&#39;</span><span> </span><span>M2&#39;&#39;</span><span> </span><span>K&#39;&#39;&#39;</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?M1 = M2&#39;&#39; @ Decided K&#39;&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + add_mset ?D U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 = tl M2&#39;&#39; @ Decided K&#39;&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M2&#39;&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1&#39;&#39; C&#8250;</span></span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1&#39;&#39; C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>C</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span>M1</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1&#39;&#39;, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span>M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1&#39;&#39;, N, add_mset ?D U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_exception_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup ?M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1&#39;&#39; K&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8713; lits_of_l M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; - K&#39;&#39; &#8713; lits_of_l M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (tl M2&#39;&#39; @ Decided K&#39;&#39;&#39; # []) K&#39;&#39;&#8250;</span></span></span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO tune proof *)</span></span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atm_lit_of_set_lits_of_l</span><span>
</span><span>                </span><span>atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set</span><span>
</span><span>                </span><span>defined_lit_map</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>image_Un</span><span>
</span><span>                </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_uminus_append_in_atm_notin</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_M1_K&#39;&#39;</span><span>  </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M1&#39;&#39;</span><span> </span><span>K&#39;&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M1</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span> </span><span>Int_Un_distrib</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1&#39;&#39; ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1&#39;&#39; ?D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1&#39;&#39;, N, add_mset (TWL_Clause {#K&#39;, K&#39;&#39;#} (D&#39; - {#K&#39;, K&#39;&#39;#})) U, None,
           NE, UE, {#}, {#}) ?D&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>get_level_cons_if</span><span>
</span><span>            </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update M1&#39;&#39; C&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level M1&#39;&#39; C&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1&#39;&#39;, N, add_mset (TWL_Clause {#K&#39;, K&#39;&#39;#} (D&#39; - {#K&#39;, K&#39;&#39;#})) U, None,
         NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1&#39;&#39;</span><span> </span><span>M2&#39;&#39;</span><span> </span><span>K&#39;&#39;&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?M1 = M2&#39;&#39; @ Decided K&#39;&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 = tl M2&#39;&#39; @ Decided K&#39;&#39;&#39; # M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M2&#39;&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1&#39;&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1&#39;&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1&#39;&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>M</span><span> </span><span>M1</span><span> </span><span>past_invs.simps</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>propa_cands_enqueued.simps</span><span>
</span><span>          </span><span>confl_cands_enqueued.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK&#39;&#39;_M1&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39;&#39; &#8713; lits_of_l M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>K&#39;&#39;_M1&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (tl M2&#39;&#39; @ Decided K&#39;&#39;&#39; # []) (-K&#39;&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_dup_append_in_atm_notin</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K&#39;&#39;_M1&#39;&#39;</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: M M1 no_dup_def; fail&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_M1_K&#39;&#39;</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M1&#39;&#39;</span><span> </span><span>K&#39;&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>M1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uK&#39;_M1&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- K&#39; &#8713; lits_of_l M1&#39;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>K&#39;_M1&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M3 @ M2 @ Decided K # tl M2&#39;&#39; @ Decided K&#39;&#39;&#39; # []) (-K&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_dup_append_in_atm_notin</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K&#39;_M1&#39;&#39;</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: M M1; fail&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K&#39;</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M1&#39;&#39;</span><span> </span><span>K&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>M1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;clauses_to_update_prop {#} M1&#39;&#39; (L, ?D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK&#39;_M1&#39;&#39;</span><span> </span><span>uK&#39;&#39;_M1&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1&#39;&#39;, N, add_mset ?D U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1&#39;&#39;, N, add_mset ?D U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1&#39;&#39;, N, add_mset ?D U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands</span><span> </span><span>propa_cands</span><span> </span><span>w_q</span><span> </span><span>uK&#39;_M1&#39;&#39;</span><span> </span><span>uK&#39;&#39;_M1&#39;&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>cdcl_twl_o_valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cdcl_twl_o_conflict_None_queue</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict T &#8800; None &#10233; clauses_to_update T = {#} &#8743; literals_to_update T = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>cdcl_twl_o_no_duplicate_queued</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>cdcl_twl_o_distinct_queued</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_o_twl_st_exception_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decide</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>in_atms</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv (M, N, NE, None, U, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, NE, None, U, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span> </span><span>twl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decide.hyps</span><span> </span><span>n_d</span><span> </span><span>excep</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_decide&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>skip</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>resolve</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_unit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Propagated L {#L#} # M1, N, U, None, NE, add_mset {#L#} UE, {#}, {#- L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of ?U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv ?T C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_appendD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?U)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_o.backtrack_unit_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack_unit_clause.hyps</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span>valid</span><span> </span><span>struct_inv_T</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>excep</span><span> </span><span>undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_nonunit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>13</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TWL_Clause {#L, L&#39;#} (D&#39; - {#L, L&#39;#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Propagated L D&#39; # M1, N, add_mset ?D U, None, NE, UE, {#}, {#- L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv ?T C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_appendD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?U)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_o.backtrack_nonunit_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack_nonunit_clause.hyps</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span>valid</span><span> </span><span>struct_inv_T</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (Propagated L D&#39; # M1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv_U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = count_decided M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>lev_K</span><span> </span><span>n_d_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>get_level_cons_if</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_L&#39;_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (Propagated L D&#39; # M1) L&#39; = count_decided M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>lev_L&#39;</span><span> </span><span>n_d_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>get_level_cons_if</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit (Propagated L D&#39; # M1) (add_mset L (add_mset L&#39; (D&#39; - {#L, L&#39;#}))) L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L&#39;</span><span> </span><span>lev_L&#39;_M1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>excep</span><span> </span><span>undef</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_propagate&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO refactor: the two backtrack ?cases are copy-paste from each other.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>cdcl_twl_o_confl_cands_enqueued</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cdcl_twl_o_propa_cands_enqueued</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_o_clauses_to_update</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>twl</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decide</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>U</span><span> </span><span>UE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided L # M, N, U, None, NE, UE, {#}, {#-L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl_cand</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl_twl_o.decide</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decide.hyps</span><span class="delimiter">]</span><span> </span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simp_all add: twl_struct_invs_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (Decided L # M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confl_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>LM_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided L # M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span>K</span><span> </span><span>K&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#K, K&#39;#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;M &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cand</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>neg_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# clause C. -K &#8712; lits_of_l (Decided L # M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LM_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched (TWL_Clause {#K, K&#39;#} UW) &#10230;
              - L &#8712; lits_of_l M &#10230; &#172; has_blit M (clause (TWL_Clause {#K, K&#39;#} UW)) L &#10230;
      L &#8713;# {#} &#10230;
      (L, TWL_Clause {#K, K&#39;#} UW) &#8713;# {#} &#10230;
      (&#8704;K&#8712;#unwatched (TWL_Clause {#K, K&#39;#} UW).
          - K &#8712; lits_of_l M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched (TWL_Clause {#K, K&#39;#} UW) &#10230;
              - L &#8712; lits_of_l M &#10230; &#172; has_blit M (clause (TWL_Clause {#K, K&#39;#} UW)) L &#10230;
           (&#8704;K&#8712;#unwatched (TWL_Clause {#K, K&#39;#} UW). - K &#8712; lits_of_l M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# watched C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>uL_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_UW</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# UW&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; -L &#8744; K&#39; &#8800; -L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist_C</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>uL_W</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>            </span><span>no_dup_cannot_not_lit_and_uminus</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>disj</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(-K &#8712; lits_of_l M &#8743; K&#39; &#8713; lits_of_l M) &#8744;
         (-K&#39; &#8712; lits_of_l M &#8743; K &#8713; lits_of_l M)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_W</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause C) K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause C) K&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# unwatched C. -K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>disj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_clause.sel</span><span> </span><span>member_add_mset</span><span> </span><span>W</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span class="delimiter">[</span><span>of</span><span> </span><span>K&#39;</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>twl_clause.sel</span><span> </span><span>member_add_mset</span><span> </span><span>W</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_W</span><span> </span><span>uL_C</span><span> </span><span>L_M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>FK</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;FK &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>LM_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided L # M &#8872;as CNot (remove1_mset FK (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (Decided L # M) FK&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_M_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M FK&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; M &#8872;as CNot (remove1_mset FK (clause C))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands</span><span> </span><span>C</span><span> </span><span>K</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>neg_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# remove1_mset FK (clause C). -K &#8712; lits_of_l (Decided L # M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LM_C</span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# watched C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>uL_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span>K</span><span> </span><span>K&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#K, K&#39;#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_C</span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span> </span><span>remove1_mset_add_mset_If</span><span>
</span><span>          </span><span>add_mset_commute</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FK_F</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;FK &#8800; K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>uK_M</span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>uL_W</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; -L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>uL_W</span><span> </span><span>n_d</span><span> </span><span>uK_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>            </span><span>no_dup_cannot_not_lit_and_uminus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; = FK&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>FK_F</span><span> </span><span>n_d</span><span> </span><span>uL_W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remove1_mset_add_mset_If</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>            </span><span>lits_of_def</span><span> </span><span>no_dup_cannot_not_lit_and_uminus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause C) K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>neg_C</span><span> </span><span>undef_M_K</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M (clause C) K&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; K &#8713; lits_of_l M&#8250;</span></span></span><span>  </span><span>K</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>neg_C</span><span> </span><span>undef_M_K</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# unwatched C. -K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_W</span><span> </span><span>L_M</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712;# clause C&#8250;</span></span></span><span> </span><span>uL_W</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_nempty</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_empty</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_prop.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_decide&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Q</span><span> </span><span>K</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_has_blit_decide&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>skip</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>resolve</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_unit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Propagated L {#L#} # M1, N, U, None, NE, add_mset {#L#} UE, {#}, {#- L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>     </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?U)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.backtrack_unit_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack_unit_clause.hyps</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1.prems&quot;</span></span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?U)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d_L_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (Propagated L {#L#} # M1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>     </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>atm_lit_of_set_lits_of_l</span><span> </span><span>atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C &#8712;# N + U. twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confl_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>LM_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L {#L#} # M1 &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span>K</span><span> </span><span>K&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#K, K&#39;#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;M1 &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>neg_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# clause C. -K &#8712; lits_of_l (Decided L # M1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LM_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K&#39;_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8800; L&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>C_W</span><span> </span><span>LM_C</span><span> </span><span>W</span><span> </span><span>add_diff_cancel_right&#39;</span><span> </span><span>clause.simps</span><span> </span><span>consistent_interp_def</span><span>
</span><span>          </span><span>distinct_consistent_interp</span><span> </span><span>in_CNot_implies_uminus</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>in_diffD</span><span> </span><span>n_d_L_M1</span><span> </span><span>uL_C</span><span>
</span><span>          </span><span>union_single_eq_member</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_W</span><span> </span><span>LM_C</span><span> </span><span>W</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# watched C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>uL_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; -L &#8744; K&#39; &#8800; -L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist_C</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (lits_of_l M1)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_consistent_interp</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_lit_of_set_lits_of_l</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>add_diff_cancel_right&#39;</span><span>
</span><span>              </span><span>atm_of_eq_atm_of</span><span> </span><span>clause.simps</span><span>
</span><span>              </span><span>consistent_interp_def</span><span> </span><span>in_diffD</span><span> </span><span>insertE</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span> </span><span>lits_of_insert</span><span> </span><span>uL_C</span><span>
</span><span>              </span><span>union_single_eq_member</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span>n_d_L_M1</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>uL_W</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(-K &#8712; lits_of_l M1 &#8743; K&#39; &#8713; lits_of_l M1) &#8744;
          (-K&#39; &#8712; lits_of_l M1 &#8743; K &#8713; lits_of_l M1)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_W</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep_M1</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>          </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d_L_M1</span><span class="delimiter">]</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>          </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>10</span><span> </span><span>10</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# unwatched C. -K &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>union_single_eq_member</span><span> </span><span>w_q</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>all_conj_distrib</span><span> </span><span>L_M</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_W</span><span> </span><span>uL_C</span><span> </span><span>L_M</span><span> </span><span>K_L</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>FK</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;FK &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>LM_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L {#L#} # M1 &#8872;as CNot (remove1_mset FK (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (Propagated L {#L#} # M1) FK&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_M_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (Propagated L D # M1) FK&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; M1 &#8872;as CNot (remove1_mset FK (clause C))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands</span><span> </span><span>C</span><span> </span><span>K</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>neg_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# remove1_mset FK (clause C). -K &#8712; lits_of_l (Propagated L D # M1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LM_C</span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# watched C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>uL_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span>K</span><span> </span><span>K&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#K, K&#39;#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-K &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_C</span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span> </span><span>remove1_mset_add_mset_If</span><span>
</span><span>            </span><span>add_mset_commute</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &#8249;K&#39; &#8713; lits_of_l M1&#8250; and *)</span></span></span></span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (lits_of_l M1)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_consistent_interp</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_lit_of_set_lits_of_l</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span> </span><span>uK_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FK_F</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;FK &#8800; K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; -L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>uL_W</span><span> </span><span>n_d</span><span> </span><span>uK_M</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>            </span><span>no_dup_cannot_not_lit_and_uminus</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_cannot_not_lit_and_uminus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; = FK&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>FK_F</span><span> </span><span>n_d</span><span> </span><span>uL_W</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remove1_mset_add_mset_If</span><span>
</span><span>            </span><span>uminus_lit_swap</span><span> </span><span>lits_of_def</span><span> </span><span>no_dup_cannot_not_lit_and_uminus</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_cannot_not_lit_and_uminus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep_M1</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>          </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>K</span><span> </span><span>undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d_L_M1</span><span class="delimiter">]</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add_mset_commute</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>defined_lit_uminus</span><span> </span><span>in_lits_of_l_defined_litD</span><span>
</span><span>            </span><span>insert_DiffM</span><span> </span><span>no_dup_consistentD</span><span> </span><span>set_subset_Cons</span><span> </span><span>true_annot_mono</span><span> </span><span>true_annot_singleton</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>          </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span> </span><span>K</span><span> </span><span>undef</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>10</span><span> </span><span>10</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add_mset_commute</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>defined_lit_uminus</span><span> </span><span>in_lits_of_l_defined_litD</span><span>
</span><span>            </span><span>insert_DiffM</span><span> </span><span>no_dup_consistentD</span><span> </span><span>set_subset_Cons</span><span> </span><span>true_annot_mono</span><span> </span><span>true_annot_singleton</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# unwatched C. -K &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_W</span><span> </span><span>uL_M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712;# clause C&#8250;</span></span></span><span> </span><span>uL_W</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L. Pair L `# {#C &#8712;# N + U. clauses_to_update_prop {#} M1 (L, C)#} = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L C. C &#8712;# N + U &#10233; L &#8712;# watched C &#10233; - L &#8712; lits_of_l M1 &#10233;
      &#172; has_blit M1 (clause C) L &#10233; (L, C) &#8713;# {#} &#10233; L &#8712;# {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_nempty</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_empty</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span class="delimiter">]</span><span>  </span><span>n_d_L_M1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>Ball_def</span><span> </span><span>image_mset_is_empty_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Q</span><span> </span><span>K</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>has_blit_Cons</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_nonunit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>LD</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_max_L</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>LD&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TWL_Clause {#L, L&#39;#} (D&#39; - {#L, L&#39;#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Propagated L D&#39; # M1, N, add_mset ?D U, None, NE,
    UE, {#}, {#- L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>     </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M3 @ M2 @ M1) K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_dup_append_in_atm_notin</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[Decided K]&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: no_dup_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_uL&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; - L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>lev_L&#39;</span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?U)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.backtrack_nonunit_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack_nonunit_clause.hyps</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1.prems&quot;</span></span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?U)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d_L_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (Propagated L D&#39; # M1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>     </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_CNot_L_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot (remove1_mset L D&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>     </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>n_d_L_M1</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excep_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C &#8712;# N + U. twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confl_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + add_mset ?D U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>LM_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L D&#39; # M1 &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?U&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.backtrack_nonunit_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack_nonunit_clause.hyps</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1.prems&quot;</span></span></span><span>
</span><span>        </span><span>cdcl_twl_o_twl_st_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls ?D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LM_C</span><span> </span><span>L_uL&#39;</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>            </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv</span><span> </span><span>C</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span>K</span><span> </span><span>K&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#K, K&#39;#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;M1 &#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>neg_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# clause C. -K &#8712; lits_of_l (Decided L # M1)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LM_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K&#39;_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8800; L&#8250;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>C_W</span><span> </span><span>LM_C</span><span> </span><span>W</span><span> </span><span>add_diff_cancel_right&#39;</span><span> </span><span>clause.simps</span><span> </span><span>consistent_interp_def</span><span>
</span><span>            </span><span>distinct_consistent_interp</span><span> </span><span>in_CNot_implies_uminus</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>in_diffD</span><span> </span><span>n_d_L_M1</span><span> </span><span>uL_C</span><span>
</span><span>            </span><span>union_single_eq_member</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_W</span><span> </span><span>LM_C</span><span> </span><span>W</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>uL_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713;# watched C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; -L &#8744; K&#39; &#8800; -L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist_C</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (lits_of_l M1)&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_consistent_interp</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_lit_of_set_lits_of_l</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>add_diff_cancel_right&#39;</span><span>
</span><span>                </span><span>atm_of_eq_atm_of</span><span> </span><span>clause.simps</span><span> </span><span>consistent_interp_def</span><span> </span><span>in_diffD</span><span> </span><span>insertE</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span>
</span><span>                </span><span>lits_of_insert</span><span> </span><span>uL_C</span><span> </span><span>union_single_eq_member</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span>n_d_L_M1</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>uL_W</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(-K &#8712; lits_of_l M1 &#8743; K&#39; &#8713; lits_of_l M1) &#8744;
            (-K&#39; &#8712; lits_of_l M1 &#8743; K &#8713; lits_of_l M1)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_W</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>            </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d_L_M1</span><span class="delimiter">]</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>            </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_C</span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>10</span><span> </span><span>10</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep_M1</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# unwatched C. -K &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span>twl_clause.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>union_single_eq_member</span><span> </span><span>w_q</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>all_conj_distrib</span><span>
</span><span>              </span><span>L_M</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL_W</span><span> </span><span>uL_C</span><span> </span><span>L_M</span><span> </span><span>K_L</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propa_cands_enqueued.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>FK</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + add_mset ?D U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;FK &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>LM_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L D&#39; # M1 &#8872;as CNot (remove1_mset FK (clause C))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (Propagated L D&#39; # M1) FK&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ?D&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_M_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (Propagated L D # M1) FK&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; M1 &#8872;as CNot (remove1_mset FK (clause C))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands</span><span> </span><span>C</span><span> </span><span>K</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# clause C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>neg_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# remove1_mset FK (clause C). -K &#8712; lits_of_l (Propagated L D # M1)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LM_C</span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# watched C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>uL_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8713;# watched C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>W</span><span> </span><span>UW</span><span> </span><span>K</span><span> </span><span>K&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>C_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = TWL_Clause W UW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W = {#K, K&#39;#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-K &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_C</span><span> </span><span>neg_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span> </span><span>remove1_mset_add_mset_If</span><span>
</span><span>              </span><span>add_mset_commute</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FK_F</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;FK &#8800; K&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; -L&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span> </span><span>uL_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>uL_W</span><span> </span><span>n_d</span><span> </span><span>uK_M</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>              </span><span>no_dup_cannot_not_lit_and_uminus</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_cannot_not_lit_and_uminus</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; = FK&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_M_K</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>FK_F</span><span> </span><span>n_d</span><span> </span><span>uL_W</span><span> </span><span>n_d_L_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remove1_mset_add_mset_If</span><span>
</span><span>              </span><span>uminus_lit_swap</span><span> </span><span>lits_of_def</span><span> </span><span>no_dup_cannot_not_lit_and_uminus</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_cannot_not_lit_and_uminus</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep_M1</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8713; lits_of_l M1&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>            </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>undef</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d_L_M1</span><span class="delimiter">]</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;has_blit M1 (clause C) K&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; K &#8713; lits_of_l M1&#8250;</span></span></span><span> </span><span>uL_M1</span><span>
</span><span>            </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_L_M1</span><span> </span><span>no_dup_cons</span><span> </span><span>no_dup_consistentD</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>undef</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_C</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv (M1, N, U, None, NE, UE, {#}, {#}) C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excep_M1</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K &#8712;# unwatched C. -K &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uK_M</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span> </span><span>C_W</span><span> </span><span>W</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_W</span><span> </span><span>uL_M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712;# clause C&#8250;</span></span></span><span> </span><span>uL_W</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;L&#39;. L&#39; &#8712;# watched C &#8743; L&#39; &#8712;# {#- L#}) &#8744; (&#8707;L. (L, C) &#8712;# {#})&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#remove1_mset L D&#39;. - K &#8712; lits_of_l (Propagated L D&#39; # M1)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M1_CNot_L_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#remove1_mset L D&#39;. defined_lit (Propagated L D&#39; # M1) K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit (Propagated L D&#39; # M1) L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#D&#39;. defined_lit (Propagated L D&#39; # M1) K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_remove1_mset_neq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;K&#8712;#clause ?D. defined_lit (Propagated L D&#39; # M1) K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LD&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit (Propagated L D&#39; # M1) L&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L. Pair L `# {#C &#8712;# N + U. clauses_to_update_prop {#} M1 (L, C)#} = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L C. C &#8712;# N + U &#10233; L &#8712;# watched C &#10233; - L &#8712; lits_of_l M1 &#10233;
       &#172; has_blit M1 (clause C) L &#10233; (L, C) &#8713;# {#} &#10233; L &#8712;# {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_to_update_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = count_decided M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>lev_K</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>get_level_cons_if</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_L&#39;_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (Propagated L D&#39; # M1) L&#39; = count_decided M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>lev_L&#39;</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>get_level_cons_if</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>blit_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;has_blit (Propagated L D&#39; # M1) (add_mset L (add_mset L&#39; (D&#39; - {#L, L&#39;#}))) L&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_blit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lev_L&#39;_M1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_inv_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_nempty</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WS_empty</span><span> </span><span>K&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">[</span><span>of</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;3&quot;</span></span></span><span> </span><span>n_d_L_M1</span><span> </span><span>L_M1</span><span> </span><span>blit_L&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>Ball_def</span><span> </span><span>image_mset_is_empty_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Q</span><span> </span><span>K&#39;</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span>K&#39;</span><span class="delimiter">]</span><span> </span><span>uL_M1</span><span> </span><span>blit_L&#39;</span><span> </span><span>n_d_L_M1</span><span> </span><span>has_blit_Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_to_update_prop.simps</span><span>
</span><span>          </span><span>add_mset_eq_add_mset</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_dup_append_decided_Cons_lev</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (M2 @ Decided K # M1)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1 = get_level (M2 @ Decided K # M1) K - 1&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M2 @ M1) K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_dup_append_in_atm_notin</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[Decided K]&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_o_entailed_clss_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>unit</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decide</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>U</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv (M, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8800; atm_of K&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;La. La &#8712;# C &#8743; (None = None &#8744; 0 &lt; count_decided (Decided L # M) &#10230;
      get_level (Decided L # M) La = 0 &#8743; La &#8712; lits_of_l (Decided L # M))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>skip</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L C&#39; # M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv (?M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M = 0&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L. L &#8712;# C &#8743; (Some D = None &#8744; 0 &lt; count_decided M &#10230;
        get_level M L = 0 &#8743; L &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; lits_of_l ?M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level ?M K = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level ?M L &gt; 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8800; atm_of K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L. L &#8712;# C &#8743; (Some D = None &#8744; 0 &lt; count_decided M &#10230;
        get_level M L = 0 &#8743; L &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>resolve</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L C # M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Some (remove1_mset (- L) D &#8746;# remove1_mset L C)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv (?M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M = 0&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>E</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# E&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;La. La &#8712;# E &#8743; (?D = None &#8744; 0 &lt; count_decided M &#10230;
        get_level M La = 0 &#8743; La &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>E</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# E&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; lits_of_l ?M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level ?M K = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level ?M L &gt; 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8800; atm_of K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;La. La &#8712;# E &#8743; (?D = None &#8744; 0 &lt; count_decided M &#10230;
         get_level M La = 0 &#8743; La &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_unit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_L</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Propagated L {#L#} # M1, N, U, None, NE, add_mset {#L#} UE, {#}, {#- L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L {#L#} # M1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; = (M3 @ M2) @ Decided K # []&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2&#39; @ M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>M2&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_dec_M2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M2&#39; &#8800; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M2&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_dec_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1 = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_append_decided_Cons_lev</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M3 @ M2&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span class="delimiter">]</span><span>
</span><span>      </span><span>lev_K</span><span> </span><span>n_d</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE +  add_mset {#L#} UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;La. La &#8712;# C&#8743; (None = None &#8744; 0 &lt; count_decided ?M &#10230; get_level ?M La = 0 &#8743;
        La &#8712; lits_of_l ?M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>lev_K&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span>lev_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M2&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L&#8712;set ((M3 @ M2) @ [Decided K]). &#172; atm_of (lit_of L) &#8800; atm_of K&#39;&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>M2&#39;_def</span><span> </span><span>image_iff</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (M2&#39; @ M1) K&#39;&#39; = get_level M2&#39; K&#39;&#39; + count_decided M1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M2&#39;&#8250;</span></span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>get_level_skip_end</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>last_in_set_dropWhile</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ex_L</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>M2&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;get_level M K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M2&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty_conv</span><span> </span><span>get_level_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l ?M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8800; atm_of K&#39;&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_L</span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span>lev_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atm_of_eq_atm_of</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level ?M K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_dec_M1</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?M</span><span> </span><span>K&#39;&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = {#L#}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_dec_M1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack_nonunit_clause</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_L_M</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>13</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, Some D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Propagated L D&#39; # M1, N, add_mset (TWL_Clause {#L, L&#39;#} (D&#39; - {#L, L&#39;#})) U, None,
    NE, UE, {#}, {#-L#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L D&#39; # M1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; = (M3 @ M2) @ Decided K # []&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2&#39; @ M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>M2&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_dec_M2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M2&#39; &#8800; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M2&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_dec_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1 = i&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_append_decided_Cons_lev</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M3 @ M2&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span class="delimiter">]</span><span>
</span><span>      </span><span>lev_K</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span> </span><span>Ball_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>lev_K&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span>lev_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K&#39;&#39;_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M2&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L&#8712;set ((M3 @ M2) @ [Decided K]). &#172; atm_of (lit_of L) &#8800; atm_of K&#39;&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>M2&#39;_def</span><span> </span><span>image_iff</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L&#8712;set ((M3 @ M2) @ [Decided K]). &#172; atm_of (lit_of L) &#8800; atm_of K&#39;&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>M2&#39;_def</span><span> </span><span>image_iff</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (M2&#39; @ M1) K&#39;&#39; = get_level M2&#39; K&#39;&#39; + count_decided M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M2&#39;&#8250;</span></span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>get_level_skip_end</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>last_in_set_dropWhile</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ex_L</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>M2&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;get_level M K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l M2&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty_conv</span><span> </span><span>get_level_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39;&#39; &#8712; lits_of_l ?M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (M3 @ M2 @ [Decided K]) K&#39;&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_dup_append_in_atm_notin</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span>M</span><span> </span><span>K&#39;&#39;_M1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M1 K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8800; atm_of K&#39;&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K&#39;&#39;</span><span> </span><span>lev_M</span><span> </span><span>lev_L_M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>get_level_uminus</span><span> </span><span>not_gr_zero</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level ?M K&#39;&#39; = 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;La. La &#8712;# C &#8743; (None = None &#8744; 0 &lt; count_decided ?M &#10230;
        get_level ?M La = 0 &#8743; La &#8712; lits_of_l ?M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The Strategy&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_literals_to_update_no_cp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>WS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, U, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>WS</span><span> </span><span>Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict S = None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>WS</span><span> </span><span>Q</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>excep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv S&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M &#10233; -L &#8713; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consistent_interp_def</span><span> </span><span>distinct_consistent_interp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C &#8712;# N + U. &#172;M&#8872;as CNot (clause C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;M&#8872;as CNot C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;a C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annot_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">:</span><span> </span><span>L_uL</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflictE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>trail.simps</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clause `# (N + U) + NE + UE&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot (remove1_mset L C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagateE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>trail.simps</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clause `# (N + U)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + UE&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>L&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39;&#39; &#8712;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39;&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span>L&#39;&#39;</span><span> </span><span>L&#39;&#39;_def</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>L_uL</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>              </span><span>add_mset_eq_add_mset</span><span>
</span><span>              </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ns_confl</span><span> </span><span>ns_propa</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict S &#8800; None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagateE</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflictE</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>conflicting.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  When popping a literal from \&lt;^term&gt;&#8249;literals_to_update&#8250; to the \&lt;^term&gt;&#8249;clauses_to_update&#8250;,
  we do not do any transition in the abstract transition system. Therefore, we use
  \&lt;^term&gt;&#8249;rtranclp&#8250; or a case distinction.
  &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) &#8744;
    (state<span class="hidden">&#8681;</span><sub>W</sub>_of S = state<span class="hidden">&#8681;</span><sub>W</sub>_of T &#8743; (literals_to_update_measure T, literals_to_update_measure S)
    &#8712; lexn less_than 2)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>cp</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>other&#39;</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>o</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.cases</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.other&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_literals_to_update_no_cp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wq</span><span> </span><span>p</span><span> </span><span>twl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_literals_to_update_no_cp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wq</span><span> </span><span>p</span><span> </span><span>twl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>o</span><span class="delimiter">]</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_o_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_o.cases</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.other&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_literals_to_update_no_cp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wq</span><span> </span><span>p</span><span> </span><span>twl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_literals_to_update_no_cp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wq</span><span> </span><span>p</span><span> </span><span>twl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>cdcl</span><span class="delimiter">]</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>init</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) = init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_init_clss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_twl_st_inv</span><span> </span><span>twl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_valid</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>twl</span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_smaller_propa</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span class="delimiter">(</span><span>use</span><span> </span><span>twl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simp add: init twl_struct_invs_def; fail&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_twl_st_exception_inv</span><span> </span><span>twl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_no_duplicate_queued</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_distinct_queued</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_confl_cands_enqueued</span><span> </span><span>twl</span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_propa_cands_enqueued</span><span> </span><span>twl</span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>twl</span><span> </span><span>cdcl_twl_o_conflict_None_queue</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;blast; fail&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_entailed_clss_inv</span><span> </span><span>twl</span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>twl_o_clauses_to_update</span><span> </span><span>twl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_o_past_invs</span><span> </span><span>twl</span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete"><a id="cdcl_twl_stgy_twl_struct_invs"></a></span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp_twl_struct_invs</span><span> </span><span>cdcl_twl_o_twl_struct_invs</span><span> </span><span>twl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_twl_struct_invs</span><span> </span><span>twl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_cdcl_twl_cp_no_step_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ns_cp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_cp S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#} &#8743; clauses_to_update S = {#}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict S&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>confl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>UE</span><span> </span><span>NE</span><span> </span><span>WS</span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, U, None, NE, UE, WS, Q)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S &#8800; {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span>WS&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>LC</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, C) &#8712;# clauses_to_update S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>WS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;WS = add_mset (L, C) WS&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>WS</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# watched C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span>LC</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_N_U</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched C = {#L, L&#39;#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_2_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# clause C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_cp.delete_from_working</span><span class="delimiter">[</span><span>of</span><span> </span><span>L&#39;</span><span> </span><span>C</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L</span><span> </span><span>WS&#39;</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>watched</span><span>
</span><span>      </span><span>ns_cp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>WS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#39; &#8744; -L&#39; &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; (&#8704;L &#8712;# unwatched C. -L &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_cp.conflict</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS&#39;</span><span> </span><span>Q</span><span class="delimiter">]</span><span>
</span><span>        </span><span>cdcl_twl_cp.propagate</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS&#39;</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>watched</span><span>
</span><span>      </span><span>ns_cp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>WS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# unwatched C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uK_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-K &#8713; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_K_K_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M K &#8744; K &#8712; lits_of_l M&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>NU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NU = (if C &#8712;# N then (add_mset (update_clause C L K) (remove1_mset C N), U)
      else (N, add_mset (update_clause C L K) (remove1_mset C U)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clauses (N, U) C L K NU&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_N_U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NU_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_clauses.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NU = (fst NU, snd NU)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_cp.update_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst NU&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd NU&#8250;</span></span></span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>WS&#39;</span><span> </span><span>Q</span><span class="delimiter">]</span><span>
</span><span>      </span><span>watched</span><span> </span><span>uL_M</span><span> </span><span>L&#39;_M</span><span> </span><span>K</span><span> </span><span>undef_K_K_M</span><span> </span><span>upd</span><span> </span><span>ns_cp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>WS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_cp.pop</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">]</span><span> </span><span>S</span><span> </span><span>ns_cp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Q&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wq</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_cdcl_twl_o_no_step_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ns_o</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_o S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, U, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>w_q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decide</span><span> </span><span>L</span><span> </span><span>T</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>confl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atm</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.decide</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>U</span><span> </span><span>UE</span><span class="delimiter">]</span><span> </span><span>confl</span><span> </span><span>undef</span><span> </span><span>atm</span><span> </span><span>ns_o</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>skip</span><span> </span><span>L</span><span> </span><span>C&#39;</span><span> </span><span>M&#39;</span><span> </span><span>E</span><span> </span><span>T</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>M</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>confl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL_E</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.skip</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>E</span><span> </span><span>C&#39;</span><span> </span><span>M&#39;</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">]</span><span> </span><span>M</span><span> </span><span>uL_E</span><span> </span><span>E</span><span> </span><span>ns_o</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>resolve</span><span> </span><span>L</span><span> </span><span>E</span><span> </span><span>M&#39;</span><span> </span><span>D</span><span> </span><span>T</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>M</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L_E</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hd</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>uL_D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>max_lvl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.resolve</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>E</span><span> </span><span>M&#39;</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">]</span><span> </span><span>M</span><span> </span><span>L_E</span><span> </span><span>ns_o</span><span> </span><span>max_lvl</span><span> </span><span>uL_D</span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span>K</span><span> </span><span>i</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>T</span><span> </span><span>D&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>confl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_L_bt</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D&#39;_C</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; = {#}&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.backtrack_unit_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L C&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#39;&#8250;</span></span></span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span class="delimiter">]</span><span>
</span><span>        </span><span>decomp</span><span> </span><span>True</span><span> </span><span>lev_L_bt</span><span> </span><span>lev_L</span><span> </span><span>i</span><span> </span><span>lev_K</span><span> </span><span>ns_o</span><span> </span><span>confl</span><span> </span><span>backtrack</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>clauses_def</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>sup.left_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>L&#39;_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712;# D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lev_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L&#39; = i&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>get_maximum_level_exists_lit_of_max_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>D&#39;</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span>confl</span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>S</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o.backtrack_nonunit_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L C&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#39;&#8250;</span></span></span><span>
</span><span>            </span><span>i</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>lev_L_bt</span><span> </span><span>lev_L</span><span> </span><span>i</span><span> </span><span>lev_K</span><span> </span><span>False</span><span> </span><span>L&#39;_C</span><span> </span><span>lev_L&#39;</span><span> </span><span>ns_o</span><span> </span><span>confl</span><span> </span><span>backtrack</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>S</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>sup.left_commute</span><span> </span><span>clauses_def</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_cdcl_twl_stgy_no_step_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_stgy S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns_cp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_cp S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ns_o</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_o S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns_cp</span><span> </span><span>no_step_cdcl_twl_cp_no_step_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cp</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_literals_to_update_no_cp</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_q</span><span> </span><span>p</span><span> </span><span>ns_o</span><span> </span><span>no_step_cdcl_twl_o_no_step_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete"><a id="full_cdcl_twl_stgy_cdclW_stgy"></a></span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_twl_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>full_def</span><span> </span><span>no_step_cdcl_twl_stgy_no_step_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span> </span><span>twl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>init_state_twl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_state_twl N &#8801; ([], N, {#}, None, {#}, {#}, {#}, {#})&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C &#8712;# N. struct_wf_twl_cls C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tauto</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C &#8712;# N. &#172;tautology (clause C)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>twl_stgy_invs_init_state_twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (init_state_twl N)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl_struct_invs_init_state_twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (init_state_twl N)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_lazy_update [] C&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_literals_false_of_max_level [] C&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_exception_inv ([], N, {#}, None, {#}, {#}, {#}, {#}) C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">;</span><span> </span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: twl_exception_inv.simps&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>size_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (clause C) &#8805; 2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;struct_wf_twl_cls C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>struct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause C &#8800; {#}&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L (clause C) &#8800; {#}&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_ne_size_imp_ne</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#}&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>use</span><span> </span><span>size_C</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: remove1_mset_empty_iff union_is_single&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset (clause `# N)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_set_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv ([], clause `# N, {#}, None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_state.simps</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa ([], clause `# N, {#}, None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>stgy_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (init_state_twl N)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_stgy_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict_non_zero_unless_level_0_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_confl_def</span><span> </span><span>init_state_twl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (init_state_twl N)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span>tauto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>clauses_to_update_prop.simps</span><span>
</span><span>        </span><span>past_invs.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>init_state_twl_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_conclusive_from_init_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_clss&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>full_cdcl_twl_stgy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_twl_stgy (init_state_twl N) T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C &#8712;# N. struct_wf_twl_cls C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_tauto</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C &#8712;# N. &#172;tautology (clause C)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) = Some {#} &#8743; unsatisfiable (set_mset (clause `# N)) &#8744;
     (conflicting (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) = None &#8743; trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) &#8872;asm clause `# N &#8743;
     satisfiable (set_mset (clause `# N)))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clause C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset (clause `# N)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_set_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (init_state_twl N)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span>no_tauto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>twl_struct_invs_init_state_twl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>full_cdcl_twl_stgy</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of (init_state_twl N)) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>full_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (init_state (clause `# N)) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>init_state.simps</span><span> </span><span>init_state_twl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.full_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_final_state_conclusive_from_init_state</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>dist</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_o_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T &#10233; twl_struct_invs S &#10233; twl_stgy_invs S &#10233; twl_stgy_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant</span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span>
</span><span>    </span><span>other&#39;</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_conflict_non_zero_unless_level_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_stgy_invs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_conflict_non_zero_unless_level_0</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.other</span><span>
</span><span>      </span><span>cdcl_twl_o_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o</span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_struct_invs_no_false_clause</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Well-foundedness&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_state<span class="hidden">&#8681;</span><sub>W</sub>_of</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) &#8743;
  cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_if_measure_f</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.wf_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_of</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_cdcl_twl_cp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). twl_struct_invs S &#8743; cdcl_twl_cp S T}&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?TWL&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?CDCL</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(T, S). cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(T, S). state<span class="hidden">&#8681;</span><sub>W</sub>_of S = state<span class="hidden">&#8681;</span><sub>W</sub>_of T &#8743;
    (literals_to_update_measure T, literals_to_update_measure S) &#8712; lexn less_than 2}&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_p_m</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). (literals_to_update_measure T, literals_to_update_measure S) &#8712; lexn less_than 2}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_if_measure_f</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lexn less_than 2&#8250;</span></span></span><span> </span><span>literals_to_update_measure</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_lexn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?CDCL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_state<span class="hidden">&#8681;</span><sub>W</sub>_of</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?P&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_p_m</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?CDCL O ?P &#8838; ?CDCL&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf (?CDCL &#8746; ?P)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_union_compatible</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?TWL &#8838; ?CDCL &#8746; ?P&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_TWL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; ?TWL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (T, S)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_TWL</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) &#8744;
      (state<span class="hidden">&#8681;</span><sub>W</sub>_of S = state<span class="hidden">&#8681;</span><sub>W</sub>_of T &#8743;
        (literals_to_update_measure T, literals_to_update_measure S) &#8712; lexn less_than 2)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_cp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; ?CDCL &#8746; ?P&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?CDCL &#8746; ?P&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_wf_cdcl_twl_cp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). twl_struct_invs S &#8743; cdcl_twl_cp<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(T, S). twl_struct_invs S &#8743; cdcl_twl_cp<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T} &#8838;
     {(T, S). twl_struct_invs S &#8743; cdcl_twl_cp S T}<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, S) &#8712; {(T, S). twl_struct_invs S &#8743; cdcl_twl_cp S T}<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8712; ?S<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tranclp_induct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>base</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>IH</span><span> </span><span>Nitpick.tranclp_unfold</span><span> </span><span>cdcl_twl_cp_twl_struct_invs</span><span>
</span><span>           </span><span>converse_tranclpE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(U, T) &#8712; ?S<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_trancl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl_twl_cp</span><span class="delimiter">]</span><span>  </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>H</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_cdcl_twl_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). twl_struct_invs S &#8743; cdcl_twl_stgy S T}&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?TWL&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?CDCL</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(T, S). cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(T, S). state<span class="hidden">&#8681;</span><sub>W</sub>_of S = state<span class="hidden">&#8681;</span><sub>W</sub>_of T &#8743;
    (literals_to_update_measure T, literals_to_update_measure S) &#8712; lexn less_than 2}&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf_p_m</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). (literals_to_update_measure T, literals_to_update_measure S) &#8712; lexn less_than 2}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_if_measure_f</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lexn less_than 2&#8250;</span></span></span><span> </span><span>literals_to_update_measure</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_lexn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?CDCL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_state<span class="hidden">&#8681;</span><sub>W</sub>_of</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?P&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_p_m</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?CDCL O ?P &#8838; ?CDCL&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf (?CDCL &#8746; ?P)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_union_compatible</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?TWL &#8838; ?CDCL &#8746; ?P&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_TWL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; ?TWL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (T, S)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_TWL</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) &#8744;
      (state<span class="hidden">&#8681;</span><sub>W</sub>_of S = state<span class="hidden">&#8681;</span><sub>W</sub>_of T &#8743;
         (literals_to_update_measure T, literals_to_update_measure S) &#8712; lexn less_than 2)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy2</span><span> </span><span>twl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; ?CDCL &#8746; ?P&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?CDCL &#8746; ?P&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_wf_cdcl_twl_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). twl_struct_invs S &#8743; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(T, S). twl_struct_invs S &#8743; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T} &#8838;
     {(T, S). twl_struct_invs S &#8743; cdcl_twl_stgy S T}<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, S) &#8712; {(T, S). twl_struct_invs S &#8743; cdcl_twl_stgy S T}<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8712; ?S<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tranclp_induct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>base</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stgy</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>twl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>IH</span><span> </span><span>Nitpick.tranclp_unfold</span><span> </span><span>cdcl_twl_stgy_twl_struct_invs</span><span>
</span><span>           </span><span>converse_tranclpE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(U, T) &#8712; ?S<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stgy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_trancl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl_twl_stgy</span><span class="delimiter">]</span><span>  </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>H</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_o_stgyD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cdcl_twl_o</span><span> </span><span>cdcl_twl_stgy</span><span class="delimiter">]</span><span> </span><span>cdcl_twl_stgy.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_cp_stgyD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cdcl_twl_cp</span><span> </span><span>cdcl_twl_stgy</span><span class="delimiter">]</span><span> </span><span>cdcl_twl_stgy.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_cdcl_twl_o_stgyD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T &#10233; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tranclp_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cdcl_twl_o</span><span> </span><span>cdcl_twl_stgy</span><span class="delimiter">]</span><span> </span><span>cdcl_twl_stgy.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_cdcl_twl_cp_stgyD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T &#10233; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tranclp_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cdcl_twl_cp</span><span> </span><span>cdcl_twl_stgy</span><span class="delimiter">]</span><span> </span><span>cdcl_twl_stgy.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_cdcl_twl_o</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S::&#39;v twl_st). twl_struct_invs S &#8743; cdcl_twl_o S T}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl_twl_stgy</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_wf_cdcl_twl_o</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S::&#39;v twl_st). twl_struct_invs S &#8743; cdcl_twl_o<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tranclp_wf_cdcl_twl_stgy</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>tranclp_cdcl_twl_o_stgyD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>propa_cands_enqueued_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U &#10233; N&#39; &#8838;# N &#10233;
     propa_cands_enqueued  (M, N, U, D, NE, UE, WS, Q) &#10233;
      propa_cands_enqueued  (M, N&#39;, U&#39;, D, NE&#39;, UE&#39;, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>confl_cands_enqueued_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U &#10233; N&#39; &#8838;# N &#10233;
     confl_cands_enqueued  (M, N, U, D, NE, UE, WS, Q) &#10233;
      confl_cands_enqueued  (M, N&#39;, U&#39;, D, NE&#39;, UE&#39;, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>twl_st_exception_inv_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U &#10233; N&#39; &#8838;# N &#10233;
     twl_st_exception_inv  (M, N, U, D, NE, UE, WS, Q) &#10233;
      twl_st_exception_inv  (M, N&#39;, U&#39;, D, NE&#39;, UE&#39;, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_exception_inv.simps</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>twl_st_inv_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U &#10233; N&#39; &#8838;# N &#10233;
     twl_st_inv (M, N, U, D, NE, UE, WS, Q) &#10233;
      twl_st_inv (M, N&#39;, U&#39;, D, NE&#39;, UE&#39;, WS, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_inv.simps</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant</span><span>
</span><span>    </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_conflict_non_zero_unless_level_0</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span>twl_stgy_invs_def</span><span>
</span><span>      </span><span>twl_struct_invs_def</span><span> </span><span>twl_struct_invs_no_false_clause</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_fast_restart_replay</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>kept</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L E. Propagated L E &#8712; set (drop (length M&#39; - n) M&#39;) &#10230; E &#8712;# N + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>U&#39;_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ([], N, U&#39;, None) (drop (length M&#39; - n) M&#39;, N, U&#39;, None)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;n. (drop (length M&#39; - n) M&#39;, N, U&#39;, None)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>M_lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause (M&#39;, N, U, None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>smaller_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_confl (M&#39;, N, U, None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stgy_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_lev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?L</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;m. M&#39; ! (length M&#39; - Suc m)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_nth_Suc</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (drop (length M&#39; - m) M&#39;) (lit_of (?L m))&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k = length M&#39; - Suc m&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sk</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M&#39; - m = Suc k&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k_le_M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (take k M&#39; @ ?L m # drop (Suc k) M&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>append_take_drop_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc k&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>k_le_M&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>no_dup_append_cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sk</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atm_in</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of (lit_of (M&#39; ! m)) &#8712; atms_of_mm N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>      </span><span class="delimiter">(</span><span>le</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &lt; length M&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="delimiter">(</span><span>ge</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &#8805; length M&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>le</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k = length M&#39; - Suc m&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sk</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M&#39; - m = Suc k&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k_le_M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>kept&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L E. Propagated L E &#8712; set (drop (length M&#39; - m) M&#39;) &#10230; E &#8712;# N + U&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span> </span><span>k_le_M&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; = take (length M&#39; - Suc m) M&#39; @ ?L m # trail (?S m)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>append_take_drop_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc k&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>k_le_M&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (?S m) (?S (Suc m))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L (m)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Decided</span><span> </span><span>K</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.decide (?S m) (?S (Suc m))&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.decide_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (?L m)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_nth_Suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atm_in</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span>k_le_M&#39;</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_eq_def</span><span> </span><span>state_def</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; ! k = Decided K&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D + {#L#} &#8712;# N + U &#10230; undefined_lit (trail (?S m)) L &#10230;
            &#172; (trail (?S m)) &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>D</span><span> </span><span>L</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_propa</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa_def</span><span>
</span><span>            </span><span>trail.simps</span><span> </span><span>clauses_def</span><span>
</span><span>            </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Dec</span><span> </span><span>Sk</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>state_eq_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N &#10230; undefined_lit (trail (?S m)) L &#10230; L &#8712;# D &#10230;
            &#172; (trail (?S m)) &#8872;as CNot (remove1_mset L D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# U&#39; &#10230; undefined_lit (trail (?S m)) L &#10230; L &#8712;# D &#10230;
            &#172; (trail (?S m)) &#8872;as CNot (remove1_mset L D)&#8250;</span></span></span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>D</span><span> </span><span>L</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L D&#8250;</span></span></span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>U&#39;_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (?S m)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate.simps</span><span> </span><span>clauses_def</span><span>
</span><span>              </span><span>state_eq_def</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# N + U&#39; &#10230; &#172; (trail (?S m)) &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>D</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_confl</span><span> </span><span>U&#39;_U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_confl_def</span><span>
</span><span>            </span><span>trail.simps</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Dec</span><span> </span><span>Sk</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>state_eq_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nsc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict (?S m)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict.simps</span><span> </span><span>clauses_def</span><span> </span><span>state_eq_def</span><span>
</span><span>              </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.other&#39;</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nsc</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nss</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.decide</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dec</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Propagated</span><span> </span><span>K</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; ! k = Propagated K C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (?S m) &#8872;as CNot (remove1_mset K C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>K_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>trail.simps</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>M&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span>Propa</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k - min (length M&#39;) k = 0&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span> </span><span>kept</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_alt_def</span><span> </span><span>Sk</span><span>
</span><span>            </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.reasons_in_clauses_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>K</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span>Propa</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (?S m) (?S (Suc m))&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>C</span><span> </span><span>K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K_C</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_C</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_nth_Suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>le</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span>k_le_M&#39;</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_eq_def</span><span>
</span><span>                </span><span>state_def</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.propagate&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>kept&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_fast_restart_replay_no_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>kept</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L E. Propagated L E &#8712; set (drop (length M&#39; - n) M&#39;) &#10230; E &#8712;# N + U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>U&#39;_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ([], N, U&#39;, None) (drop (length M&#39; - n) M&#39;, N, U&#39;, None)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;n. (drop (length M&#39; - n) M&#39;, N, U&#39;, None)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>M_lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting (M&#39;, N, U, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause (M&#39;, N, U, None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_lev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?L</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;m. M&#39; ! (length M&#39; - Suc m)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_nth_Suc</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (drop (length M&#39; - m) M&#39;) (lit_of (?L m))&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k = length M&#39; - Suc m&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sk</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M&#39; - m = Suc k&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k_le_M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (take k M&#39; @ ?L m # drop (Suc k) M&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>append_take_drop_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc k&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>k_le_M&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>no_dup_append_cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sk</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atm_in</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of (lit_of (M&#39; ! m)) &#8712; atms_of_mm N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>      </span><span class="delimiter">(</span><span>le</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &lt; length M&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="delimiter">(</span><span>ge</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;m &#8805; length M&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>le</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k = length M&#39; - Suc m&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sk</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M&#39; - m = Suc k&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k_le_M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; length M&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>kept&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L E. Propagated L E &#8712; set (drop (length M&#39; - m) M&#39;) &#10230; E &#8712;# N + U&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span> </span><span>k_le_M&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; = take (length M&#39; - Suc m) M&#39; @ ?L m # trail (?S m)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>append_take_drop_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc k&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>k_le_M&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> (?S m) (?S (Suc m))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L (m)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Decided</span><span> </span><span>K</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.decide (?S m) (?S (Suc m))&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.decide_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (?L m)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_nth_Suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atm_in</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span>k_le_M&#39;</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_eq_def</span><span> </span><span>state_def</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; ! k = Decided K&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.decide</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dec</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Propagated</span><span> </span><span>K</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; ! k = Propagated K C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>M_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (?S m) &#8872;as CNot (remove1_mset K C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>K_C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# C&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>trail.simps</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>M&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span>Propa</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k - min (length M&#39;) k = 0&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C_N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N + U&#39;&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span> </span><span>kept</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_alt_def</span><span> </span><span>Sk</span><span>
</span><span>            </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.reasons_in_clauses_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>K</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span> </span><span>Propa</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate (?S m) (?S (Suc m))&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>C</span><span> </span><span>K</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_N_U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K_C</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_C</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef_nth_Suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>le</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span>k_le_M&#39;</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>k_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Sk</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_eq_def</span><span>
</span><span>                </span><span>state_def</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>kept&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_get_init_learned_clss_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_init_learned_clss S &#8838;# get_init_learned_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induction</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp.simps</span><span> </span><span>cdcl_twl_o.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_get_init_learned_clss_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_init_learned_clss S &#8838;# get_init_learned_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induction</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_get_init_learned_clss_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_o_all_learned_diff_learned</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# get_learned_clss S &#8838;# clause `# get_learned_clss T &#8743;
     get_init_learned_clss S &#8838;# get_init_learned_clss T&#8743;
     get_all_init_clss S = get_all_init_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;induction rule: cdcl_twl_o.induct&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_clauses.simps</span><span> </span><span>size_Suc_Diff1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_cp_all_learned_diff_learned</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_cp S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# get_learned_clss S = clause `# get_learned_clss T &#8743;
     get_init_learned_clss S = get_init_learned_clss T &#8743;
     get_all_init_clss S = get_all_init_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;induction rule: cdcl_twl_cp.induct&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>D</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_clauses.simps</span><span> </span><span>size_Suc_Diff1</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_all_learned_diff_learned</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# get_learned_clss S &#8838;# clause `# get_learned_clss T &#8743;
     get_init_learned_clss S &#8838;# get_init_learned_clss T&#8743;
     get_all_init_clss S = get_all_init_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;induction rule: cdcl_twl_stgy.induct&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_cp_all_learned_diff_learned</span><span> </span><span>cdcl_twl_o_all_learned_diff_learned</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_all_learned_diff_learned</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# get_learned_clss S &#8838;# clause `# get_learned_clss T &#8743;
     get_init_learned_clss S &#8838;# get_init_learned_clss T &#8743;
     get_all_init_clss S = get_all_init_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;induction rule: rtranclp_induct&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_all_learned_diff_learned</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_all_learned_diff_learned_size</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (get_all_learned_clss T) - size (get_all_learned_clss S) &#8805;
         size (get_learned_clss T) - size (get_learned_clss S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_all_learned_diff_learned</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>size_mset_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span>-</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lexn2_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ST</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update S = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy S S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>S&#39;T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S&#39; T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ST</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tranclp_unfold_begin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS&#39;</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span>-</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>S&#39;T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>struct_S&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>final_twl_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;final_twl_state S &#10231;
      no_step cdcl_twl_stgy S &#8744; (get_conflict S &#8800; None &#8743; count_decided (get_trail S) = 0)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>conclusive_TWL_run</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_st nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conclusive_TWL_run S = SPEC(&#955;T. cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#8743; final_twl_state T)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflict_of_level_unsatisfiable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, U, Some D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>confl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_ann_decomposition M = [([], M)]&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_decision_get_all_ann_decomposition</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>dec</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: count_decided_def filter_empty_conv S cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>N_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8872;psm U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>M_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>N_U_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;ps unmark_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>N_U_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;p D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>all_decomposition_implies_def</span><span>
</span><span>        </span><span>S</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_alt_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;ps CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>true_clss_clss_true_clss_cls_true_clss_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>N_U_M</span><span> </span><span>M_D</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8872;ps CNot D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8872;p D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_U</span><span> </span><span>N_U_D</span><span> </span><span>true_clss_clss_left_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset N)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>true_clss_clss_CNot_true_clss_cls_unsatisfiable</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>satisfiable_decreasing</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflict_of_level_unsatisfiable2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S &#8800; None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (init_clss S + learned_clss S))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, U, Some D)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>confl</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_ann_decomposition M = [([], M)]&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_decision_get_all_ann_decomposition</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>dec</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: count_decided_def filter_empty_conv S cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>M_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>N_U_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;ps unmark_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>N_U_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;p D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>all_decomposition_implies_def</span><span>
</span><span>        </span><span>S</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_alt_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;ps CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>true_clss_clss_true_clss_cls_true_clss_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>N_U_M</span><span> </span><span>M_D</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;ps CNot D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset N &#8746; set_mset U &#8872;p D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_U_D</span><span> </span><span>true_clss_clss_left_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset N  &#8746; set_mset U)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>true_clss_clss_CNot_true_clss_cls_unsatisfiable</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>satisfiable_decreasing</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">1775f91f0787 </td><td align="center">271ed48b </td><td align="center">Mo 20 Jn 2020 16:45:39 CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


